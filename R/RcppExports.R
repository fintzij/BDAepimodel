# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Update eigen values, vectors, and inverse matrices analytically for the SIR 
#' model
#'
#' @param eigenvals matrix of eigenvalues with columns corresponding to irms
#' @param eigenvecs array of eigenvectors with third dimension corresponding to
#'   irms
#' @param inversevecs array of inverses of matrices of eigenvectors
#' @param irm_array array of rate matrices
#' @param complex_eigs logical vector indicating whether any eigen values are complex
#' @param first_calc boolean indicating whether this is the first time that the 
#'   eigen decomposition is being computed
#'
#' @return Updated eigenvalues, eigenvectors, and inverse matrices
#' @export
#' 
buildEigenArray_SIR <- function(real_eigenvals, imag_eigenvals, eigenvecs, inversevecs, irm_array, n_real_eigs, initial_calc) {
    invisible(.Call('BDAepimodel_buildEigenArray_SIR', PACKAGE = 'BDAepimodel', real_eigenvals, imag_eigenvals, eigenvecs, inversevecs, irm_array, n_real_eigs, initial_calc))
}

#' Update eigen values, vectors, and inverse matrices analytically for the SEIR 
#' model
#'
#' @param eigenvals matrix of eigenvalues with columns corresponding to irms
#' @param eigenvecs array of eigenvectors with third dimension corresponding to
#'   irms
#' @param inversevecs array of inverses of matrices of eigenvectors
#' @param irm_array array of rate matrices
#' @param complex_eigs logical vector indicating whether any eigen values are complex
#' @param first_calc boolean indicating whether this is the first time that the 
#'   eigen decomposition is being computed
#'
#' @return Updated eigenvalues, eigenvectors, and inverse matrices
#' @export
#' 
buildEigenArray_SEIR <- function(real_eigenvals, imag_eigenvals, eigenvecs, inversevecs, irm_array, n_real_eigs, initial_calc) {
    invisible(.Call('BDAepimodel_buildEigenArray_SEIR', PACKAGE = 'BDAepimodel', real_eigenvals, imag_eigenvals, eigenvecs, inversevecs, irm_array, n_real_eigs, initial_calc))
}

#' Update eigen values, vectors, and inverse matrices for irms
#'
#' @param eigenvals matrix of eigenvalues with columns corresponding to irms
#' @param eigenvecs array of eigenvectors with third dimension corresponding to
#'   irms
#' @param inversevecs array of inverses of matrices of eigenvectors
#' @param irm_array array of rate matrices
#' @param complex_eigs logical vector indicating whether any eigen values are complex
#'
#' @return Updated eigenvalues, eigenvectors, and inverse matrices
#' @export
#' 
buildEigenArray <- function(real_eigenvals, imag_eigenvals, eigenvecs, inversevecs, irm_array, n_real_eigs) {
    invisible(.Call('BDAepimodel_buildEigenArray', PACKAGE = 'BDAepimodel', real_eigenvals, imag_eigenvals, eigenvecs, inversevecs, irm_array, n_real_eigs))
}

#' Construct forward-backward matrices
#'
#' @param fb_mats array of FB matrices to be updated
#' @param tpm_prods array of tpm products
#' @param emit_mat matrix of emission probabilities
#' @param initdist vector of initial state probabilities
#' @param obs_time_inds vector of observation time indices
#'
#' @return Updated array of FB matrices
buildFBMats <- function(fb_mats, tpm_prods, emit_mat, initdist, obs_time_inds) {
    invisible(.Call('BDAepimodel_buildFBMats', PACKAGE = 'BDAepimodel', fb_mats, tpm_prods, emit_mat, initdist, obs_time_inds))
}

#' Update an array of rate matrices with the current rates
#'
#' @param irm_array array of rate matrices to be updated
#' @param rates matrix of rates
#' @param flow_inds matrix of indices in irm for where to place each rate
#'
#' @return updated array of rate matrices
buildRateArray <- function(irm_array, rates, flow_inds) {
    invisible(.Call('BDAepimodel_buildRateArray', PACKAGE = 'BDAepimodel', irm_array, rates, flow_inds))
}

#' Get the indices of observation times in the population level bookkeeping mtx.
#'
#' @param pop_mat population level bookkeeping matrix
#' @param obstimes vector of observation times
#'
#' @return indices of observation times
getObsTimeInds <- function(pop_mat, obstimes) {
    .Call('BDAepimodel_getObsTimeInds', PACKAGE = 'BDAepimodel', pop_mat, obstimes)
}

#' Insert subject transitions into the population-level and subject level 
#' bookkeeping matrices.
#'
#' @param path matrix of transitions to be inserted
#' @param subject subject ID
#' @param pop_mat population bookkeeping matrix in epimodel list
#' @param subj_path vector containing the subject path
#' @param subj_row_ind index stating where to begin inserting the transitions
#'
#' @return updated bookeeping objects
insertPath <- function(path, subject, pop_mat, subj_path, ind) {
    invisible(.Call('BDAepimodel_insertPath', PACKAGE = 'BDAepimodel', path, subject, pop_mat, subj_path, ind))
}

#' Join two armadillo cubes
#'
#' @param cube1
#' @param cube2
#'
#' @return new array joining cubes
joinCubes <- function(firstcube, secondcube) {
    .Call('BDAepimodel_joinCubes', PACKAGE = 'BDAepimodel', firstcube, secondcube)
}

#' Get the irm keys for the compartment counts in a population level
#' bookkeeping matrix
#'
#' @param pop_mat population level bookkeeping matrix
#' @param irm_array array of rate matrices
#' @param initdist vector of initial state probabilities
#' @param initdist_param_inds vector of indices for admissible initial states
#' @param flow_inds matrix of indices for locations in IRM for each event
#' @param keys vector of irm keys
#' @param inds indices relating to event times, along with t0 and tmax
#' @param loglik boolean indicating whether to return the likelihood or
#'     log-likelihood
#'
#' @return population level likelihood or log-likelihood
populationLikelihood <- function(pop_mat, irm_array, initdist, initdist_param_inds, flow_inds, keys, inds, loglik) {
    .Call('BDAepimodel_populationLikelihood', PACKAGE = 'BDAepimodel', pop_mat, irm_array, initdist, initdist_param_inds, flow_inds, keys, inds, loglik)
}

#' Reorder the rows of a matrix
#'
#' @param mtx matrix to be reordered
#' @param ord row order
#'
#' @return matrix with rows permuted according to ord
reorderMat <- function(oldmtx, ord) {
    .Call('BDAepimodel_reorderMat', PACKAGE = 'BDAepimodel', oldmtx, ord)
}

#' Add or remove the subject contribution from the compartment counts
#'
#' @param pop_mat population bookkeeping matrix in epimodel list
#' @param row_inds vector of row indices, 1:epimodel$ind_final_config
#' @param subj_path column inds given by the subject path
#' @param insertion Logical indicating whether the resolution should be the
#'     insertion or the removal of a path
#'
#' @return updated compartment counts
resolveSubjContrib <- function(pop_mat, ind_final_config, subj_path, insertion) {
    invisible(.Call('BDAepimodel_resolveSubjContrib', PACKAGE = 'BDAepimodel', pop_mat, ind_final_config, subj_path, insertion))
}

#' Get the irm keys for the compartment counts in a population level
#' bookkeeping matrix
#'
#' @param keys vector of keys to be modified in place
#' @param append_missing indicator to be modified in place to indicate whether 
#'   any keys are missing
#' @param inds vector of indices, generally 1:epimodel$ind_final_config
#' @param irm_lookup lookup matrix relating configurations to irm keys
#' @param pop_mat population bookkeeping matrix in epimodel list
#' @param index_state_number vector indicating which states are index states
#'
#' @return Vector of keys to index into an IRM array.
retrieveKeys <- function(inds, irm_lookup, pop_mat, index_state_num) {
    .Call('BDAepimodel_retrieveKeys', PACKAGE = 'BDAepimodel', inds, irm_lookup, pop_mat, index_state_num)
}

#' Insert subject transitions into the population-level and subject level 
#' bookkeeping matrices.
#'
#' @param subj_path subject path vector
#' @param subject ID for subject
#' @param pop_mat population level bookkeeping matrix
#' @param init_config initial configuration vector
#' @param ind_final_config index for final configuration
#' @param flow_inds matrix of flow indices
#'
#' @return extended path vector
retrieveSubjPath <- function(subj_path, subject, pop_mat, init_config, ind_final_config, flow_inds) {
    invisible(.Call('BDAepimodel_retrieveSubjPath', PACKAGE = 'BDAepimodel', subj_path, subject, pop_mat, init_config, ind_final_config, flow_inds))
}

#' Update eigen values, vectors, and inverse matrices for irms
#'
#' @param tpms array of transition probability matrices to be modified
#' @param pop_mat population level bookkeeping matrix
#' @param eigen_vals matrix of eigen values of irms
#' @param eigen_vecs array of eigen vectors of rate matrices
#' @param inverse_vecs array of inverse matrices of eigen vectors
#' @param irm_keys vector of irm array keys
#'
#' @return Updated eigenvalues, eigenvectors, and inverse matrices
sampleEventSubseq <- function(path, tpms, tpm_prods, init_ind, final_ind) {
    .Call('BDAepimodel_sampleEventSubseq', PACKAGE = 'BDAepimodel', path, tpms, tpm_prods, init_ind, final_ind)
}

#' simulateSIR function, included in this file because of difficulty including sample.h in two separate files.
#' Rcpp code to simulate a general stochastic epidemic and binomial counts.
#'
#' @param popsize population size
#' @param obstimes vector of observation times
#' @param params vector of parameters: beta, mu
#' @param init_config initial configuration of compartment counts
#'
#' @return updated bookeeping objects
simulateSIR <- function(obstimes, params, init_config) {
    .Call('BDAepimodel_simulateSIR', PACKAGE = 'BDAepimodel', obstimes, params, init_config)
}

#' Get the irm keys for the compartment counts in a population level
#' bookkeeping matrix
#'
#' @param subject
#' @param pop_mat population level bookkeeping matrix
#' @param subj_path integer vector giving the subject path
#' @param irm_array array of rate matrices
#' @param keys vector of irm keys
#' @param loglik boolean indicating whether to return the likelihood or
#'     log-likelihood
#'
#' @return subject level likelihood or log-likelihood
subjectLikelihood <- function(subject, pop_mat, subj_path, irm_array, initdist, keys, loglik) {
    .Call('BDAepimodel_subjectLikelihood', PACKAGE = 'BDAepimodel', subject, pop_mat, subj_path, irm_array, initdist, keys, loglik)
}

#' Update eigen values, vectors, and inverse matrices for irms
#'
#' @param tpm_prods array of transition probability matrix products
#' @param tpms array of transition probability matrices
#' @param pop_mat population level bookkeeping matrix
#' @param obstimes vector of observation times
#'
#' @return Updated eigenvalues, eigenvectors, and inverse matrices
tpmProdSeqs <- function(tpm_prods, tpms, obs_time_inds) {
    invisible(.Call('BDAepimodel_tpmProdSeqs', PACKAGE = 'BDAepimodel', tpm_prods, tpms, obs_time_inds))
}

#' Construct a transition probability matrix for a rate matrix with complex 
#' eigenvalues using the real canonical form of the decomposition.
#' 
#' @param vals vector of eigenvalues of type cx_vec
#' @param vecs matrix of eigenvectors (positive complex conjugate)
#' @param inv_vecs inverse matrix of eigenvectors
#' @param dt time interval
#'
#' @return Updated eigenvalues, eigenvectors, and inverse matrices
complexTPM <- function(real_vals, imag_vals, vecs, inv_vecs, dt, n_real) {
    .Call('BDAepimodel_complexTPM', PACKAGE = 'BDAepimodel', real_vals, imag_vals, vecs, inv_vecs, dt, n_real)
}

#' Update eigen values, vectors, and inverse matrices for irms
#'
#' @param tpms array of transition probability matrices to be modified
#' @param pop_mat population level bookkeeping matrix
#' @param real_eigen_vals matrix with the real parts of the eigen values
#' @param imag_eigen_vals matrix with the imaginary parts of the eigenvalues
#' @param eigen_vecs array of eigen vectors of rate matrices
#' @param inverse_vecs array of inverse matrices of eigen vectors
#' @param irm_keys vector of irm array keys
#' @param n_real_eigs integer vector indicating how many eigen values are real
#'
#' @return Updated eigenvalues, eigenvectors, and inverse matrices
tpmSeqs <- function(tpms, pop_mat, real_eigen_vals, imag_eigen_vals, eigen_vecs, inverse_vecs, irm_keys, n_real_eigs, irms) {
    invisible(.Call('BDAepimodel_tpmSeqs', PACKAGE = 'BDAepimodel', tpms, pop_mat, real_eigen_vals, imag_eigen_vals, eigen_vecs, inverse_vecs, irm_keys, n_real_eigs, irms))
}

