# This file was generated by Rcpp::compileAttributes
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Update eigen values, vectors, and inverse matrices for irms
#'
#' @param eigenvals matrix of eigenvalues with columns corresponding to irms
#' @param eigenvecs array of eigenvectors with third dimension corresponding to
#'   irms
#' @param inversevecs array of inverses of matrices of eigenvectors
#' @param irm_array array of rate matrices
#'
#' @return Updated eigenvalues, eigenvectors, and inverse matrices
buildEigenArray <- function(eigenvals, eigenvecs, inversevecs, irm_array) {
    invisible(.Call('BDAepimodel_buildEigenArray', PACKAGE = 'BDAepimodel', eigenvals, eigenvecs, inversevecs, irm_array))
}

#' Construct forward-backward matrices
#'
#' @param fb_mats array of FB matrices to be updated
#' @param tpm_prods array of tpm products
#' @param emit_mat matrix of emission probabilities
#' @param initdist vector of initial state probabilities
#' @param obs_time_inds vector of observation time indices
#'
#' @return Updated array of FB matrices
buildFBMats <- function(fb_mats, tpm_prods, emit_mat, initdist, obs_time_inds) {
    invisible(.Call('BDAepimodel_buildFBMats', PACKAGE = 'BDAepimodel', fb_mats, tpm_prods, emit_mat, initdist, obs_time_inds))
}

#' Update an array of rate matrices with the current rates
#'
#' @param irm_array array of rate matrices to be updated
#' @param rates matrix of rates
#' @param flow_inds matrix of indices in irm for where to place each rate
#'
#' @return updated array of rate matrices
buildRateArray <- function(irm_array, rates, flow_inds) {
    invisible(.Call('BDAepimodel_buildRateArray', PACKAGE = 'BDAepimodel', irm_array, rates, flow_inds))
}

#' Get the indices of observation times in the population level bookkeeping mtx.
#'
#' @param pop_mat population level bookkeeping matrix
#' @param obstimes vector of observation times
#'
#' @return indices of observation times
getObsTimeInds <- function(pop_mat, obstimes) {
    .Call('BDAepimodel_getObsTimeInds', PACKAGE = 'BDAepimodel', pop_mat, obstimes)
}

#' Insert subject transitions into the population-level and subject level 
#' bookkeeping matrices.
#'
#' @param path matrix of transitions to be inserted
#' @param subject subject ID
#' @param pop_mat population bookkeeping matrix in epimodel list
#' @param config_mat subject-level bookkeeping matrix
#' @param subj_row_ind index stating where to begin inserting the transitions
#'
#' @return updated bookeeping objects
insertPath <- function(path, subject, pop_mat, config_mat, ind) {
    invisible(.Call('BDAepimodel_insertPath', PACKAGE = 'BDAepimodel', path, subject, pop_mat, config_mat, ind))
}

#' Join two armadillo cubes
#'
#' @param cube1
#' @param cube2
#'
#' @return new array joining cubes
joinCubes <- function(firstcube, secondcube) {
    .Call('BDAepimodel_joinCubes', PACKAGE = 'BDAepimodel', firstcube, secondcube)
}

#' Get the irm keys for the compartment counts in a population level
#' bookkeeping matrix
#'
#' @param pop_mat population level bookkeeping matrix
#' @param irm_array array of rate matrices
#' @param initdist vector of initial state probabilities
#' @param initdist_param_inds vector of indices for admissible initial states
#' @param flow_inds matrix of indices for locations in IRM for each event
#' @param keys vector of irm keys
#' @param inds indices relating to event times, along with t0 and tmax
#' @param loglik boolean indicating whether to return the likelihood or
#'     log-likelihood
#'
#' @return population level likelihood or log-likelihood
populationLikelihood <- function(pop_mat, irm_array, initdist, initdist_param_inds, flow_inds, keys, inds, loglik) {
    .Call('BDAepimodel_populationLikelihood', PACKAGE = 'BDAepimodel', pop_mat, irm_array, initdist, initdist_param_inds, flow_inds, keys, inds, loglik)
}

#' Reorder the rows of a matrix
#'
#' @param mtx matrix to be reordered
#' @param ord row order
#'
#' @return matrix with rows permuted according to ord
reorderMat <- function(oldmtx, ord) {
    .Call('BDAepimodel_reorderMat', PACKAGE = 'BDAepimodel', oldmtx, ord)
}

#' Add or remove the subject contribution from the compartment counts
#'
#' @param pop_mat population bookkeeping matrix in epimodel list
#' @param row_inds vector of row indices, 1:epimodel$ind_final_config
#' @param col_inds column inds given by the subject path in epimodel$config_mat
#' @param insertion Logical indicating whether the resolution should be the
#'     insertion or the removal of a path
#'
#' @return updated compartment counts
resolveSubjContrib <- function(pop_mat, row_inds, col_inds, insertion) {
    invisible(.Call('BDAepimodel_resolveSubjContrib', PACKAGE = 'BDAepimodel', pop_mat, row_inds, col_inds, insertion))
}

#' Get the irm keys for the compartment counts in a population level
#' bookkeeping matrix
#'
#' @param inds vector of indices, generally 1:epimodel$ind_final_config
#' @param irm_lookup lookup matrix relating configurations to irm keys
#' @param pop_mat population bookkeeping matrix in epimodel list
#' @param index_state_number vector indicating which states are index states
#'
#' @return Vector of keys to index into an IRM array.
retrieveKeys <- function(inds, irm_lookup, pop_mat, index_state_num) {
    .Call('BDAepimodel_retrieveKeys', PACKAGE = 'BDAepimodel', inds, irm_lookup, pop_mat, index_state_num)
}

#' Update eigen values, vectors, and inverse matrices for irms
#'
#' @param tpms array of transition probability matrices to be modified
#' @param pop_mat population level bookkeeping matrix
#' @param eigen_vals matrix of eigen values of irms
#' @param eigen_vecs array of eigen vectors of rate matrices
#' @param inverse_vecs array of inverse matrices of eigen vectors
#' @param irm_keys vector of irm array keys
#'
#' @return Updated eigenvalues, eigenvectors, and inverse matrices
sampleEventSubseq <- function(path, tpms, tpm_prods, init_ind, final_ind) {
    invisible(.Call('BDAepimodel_sampleEventSubseq', PACKAGE = 'BDAepimodel', path, tpms, tpm_prods, init_ind, final_ind))
}

#' Get the irm keys for the compartment counts in a population level
#' bookkeeping matrix
#'
#' @param subject
#' @param pop_mat population level bookkeeping matrix
#' @param config_mat subject_level bookkeeping matrix for configurations
#' @param irm_array array of rate matrices
#' @param keys vector of irm keys
#' @param inds indices relating to event times, along with t0 and tmax
#' @param loglik boolean indicating whether to return the likelihood or
#'     log-likelihood
#'
#' @return subject level likelihood or log-likelihood
subjectLikelihood <- function(subject, pop_mat, config_mat, irm_array, initdist, keys, inds, loglik) {
    .Call('BDAepimodel_subjectLikelihood', PACKAGE = 'BDAepimodel', subject, pop_mat, config_mat, irm_array, initdist, keys, inds, loglik)
}

#' Update eigen values, vectors, and inverse matrices for irms
#'
#' @param tpm_prods array of transition probability matrix products
#' @param tpms array of transition probability matrices
#' @param pop_mat population level bookkeeping matrix
#' @param obstimes vector of observation times
#'
#' @return Updated eigenvalues, eigenvectors, and inverse matrices
tpmProdSeqs <- function(tpm_prods, tpms, obs_time_inds) {
    invisible(.Call('BDAepimodel_tpmProdSeqs', PACKAGE = 'BDAepimodel', tpm_prods, tpms, obs_time_inds))
}

#' Update eigen values, vectors, and inverse matrices for irms
#'
#' @param tpms array of transition probability matrices to be modified
#' @param pop_mat population level bookkeeping matrix
#' @param eigen_vals matrix of eigen values of irms
#' @param eigen_vecs array of eigen vectors of rate matrices
#' @param inverse_vecs array of inverse matrices of eigen vectors
#' @param irm_keys vector of irm array keys
#'
#' @return Updated eigenvalues, eigenvectors, and inverse matrices
tpmSeqs <- function(tpms, pop_mat, eigen_vals, eigen_vecs, inverse_vecs, irm_keys) {
    invisible(.Call('BDAepimodel_tpmSeqs', PACKAGE = 'BDAepimodel', tpms, pop_mat, eigen_vals, eigen_vecs, inverse_vecs, irm_keys))
}

