---
title: "Implementing the SEIR, SIIR, and SIRS stochastic epidemic models in the BDAepimodel package"
author: "Jon Fintzi, Jon Wakefield, Vladimir Minin"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Additional simulations included Fintzi, Wakefield, and Minin (2016)}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

This vignette demonstrates how to implement stochastic epidemic models with SEIR and SIRS dynamics. Data are binomially distributed counts of the prevalence at each time point.

## Analyzing an epidemic with SEIR dynamics
An epidemic with SEIR dynamics was simulated in a population of 750 individuals, of which 90% were initially susceptible, 1% were initially infected, 2% were initially exposed but not yet infectious, and 7% were immune. The per–contact infectivity rate was $\beta = 0.00072$, the average latent period was two days ($\gamma = 1/2$), and the average infectious duration was five days $\mu = 1/5$, which together correspond to a basic reproduction number of $R_0 = \beta N / µ = 2.7$. Binomially sampled prevalence was observed at one week intervals over a period of three months with sampling probability $\rho=0.2$. 

This simulation aimed to establish that we could estimate the posterior distributions for the latent process and the model parameters. We set the following priors for the model parameters: $\beta\sim Gamma(0.006, 10)$, $\gamma\sim Gamma(0.4,1)$, $\mu\sim Gamma(1, 6)$, $\rho\sim Beta(5, 15)$, and $\mathbf{\mathrm{p}}_{t_1}\sim Dirichlet(9, 0.15, 0.15, 0.5)$. 

The data are simulated as follows:

```{r, warning = F, cache = T}
library(BDAepimodel)
library(Rcpp)
library(coda)
set.seed(12511)

# declare the functions for simulating from and evaluating the log-density of the measurement process

r_meas_process <- function(state, meas_vars, params){
          # in our example, rho will be the name of the binomial sampling probability parameter.
          # this function returns a matrix of observed counts
          rbinom(n = nrow(state), 
                 size = state[,meas_vars],
                 prob = params["rho"])
}

d_meas_process <- function(state, meas_vars, params, log = TRUE) {
          # note that the names of the measurement variables are endowed with suffixes "_observed" and "_augmented". This is required.
          # we will declare the names of the measurement variables shortly.
          dbinom(x = state[, paste0(meas_vars, "_observed")], 
                 size = state[, paste0(meas_vars, "_augmented")], 
                 prob = params["rho"], log = log)
}

# initialize the stochastic epidemic model object
epimodel <- init_epimodel(obstimes = seq(1, 182, by = 7),                             # vector of observation times
                          popsize = 750,                                              # population size
                          states = c("S", "E", "I", "R"),                             # compartment names
                          params = c(beta = 0.00072,                                  # per-contact infectivity parameter
                                     gamma = 0.5,                                     # latent period parameter
                                     mu = 0.2,                                        # recovery rate
                                     rho = 0.2,                                       # binomial sampling probability
                                     S0 = 0.9, E0 = 0.02, I0 = 0.01, R0 = 0.07),      # initial state probabilities
                          rates = c("beta * I", "gamma", "mu"),                       # unlumped transition rates
                          flow = matrix(c(-1, 1, 0, 0, 
                                          0, -1, 1, 0, 
                                          0, 0, -1, 1), ncol = 4, byrow = T),         # flow matrix
                          meas_vars = "I",                                            # name of measurement variable
                          r_meas_process = r_meas_process,                            # measurement process functions
                          d_meas_process = d_meas_process)

# simulate the epidemic and the dataset.  
epimodel <- simulate_epimodel(epimodel = epimodel, lump = TRUE, trim = TRUE)
plot(x = epimodel$pop_mat[,"time"], y = epimodel$pop_mat[,"I"], "l", ylim = c(-5, 200), xlab = "Time", ylab = "Prevalence")
points(x = epimodel$dat[,"time"], y = epimodel$dat[,"I"])
```

We grab the true latent path (for later comparison) along with the dataset. In order to perform inference, we will need a transition kernel for Gibbs updates of the rate parameters and the binomial sampling probability. One of the objectives of this simulation was to explore the sensitivity of the latent posterior distribution to the degree of prior information about model parameters. The code presented below displays the implementation for the case with informative parameters. We ran five chains, each for 100,000 MCMC iterations, updating 10 subject-paths per iteration. 

```{r, warning = F, cache = T}
# grab the data that was simulated previously. No need to redefine the measurement process functions, they remain unchanged.
dat <- epimodel$dat[1:12,]
true_path <- epimodel$pop_mat

# helper function for computing the sufficient statistics for the SIR model rate parameters
Rcpp::cppFunction("Rcpp::NumericVector getSuffStats(const Rcpp::NumericMatrix& pop_mat, const int ind_final_config) {
                  
          // initialize sufficient statistics
          int num_exp = 0;       // number of exposure events
          int num_inf = 0;       // number of exposed --> infectious events
          int num_rec = 0;       // number of recovery events
          double beta_suff  = 0; // integrated hazard for the exposure
          double gamma_suff = 0; // integrated hazard for addition of infectives
          double mu_suff    = 0; // integrated hazard for the recovery
          
          // initialize times
          double cur_time = 0;   // current time
          double next_time = 0;  // time of the next event
          
          // compute the sufficient statistics - loop through the pop_mat matrix until
          // reaching the row for the final observation time
          for(int j = 0; j < ind_final_config - 1; ++j) {

          cur_time = next_time;         
          next_time = pop_mat(j+1, 0); // grab the time of the next event
          
          beta_suff  += pop_mat(j, 3) * pop_mat(j, 5) * (next_time - cur_time); // add S*I*(t_{j+1} - t_j) to beta_suff
          gamma_suff += pop_mat(j, 4) * (next_time - cur_time);                 // add E*(t_{j+1} - t_j) to gamma_suff
          mu_suff    += pop_mat(j, 5) * (next_time - cur_time);                 // add I*(t_{j+1} - t_j) to mu_suff
          
          if(pop_mat(j + 1, 2) == 1) {  
                    num_exp += 1;             // if the next event is an exposure, increment the number of exposures
          } else if(pop_mat(j + 1, 2) == 2) {
                    num_inf += 1;             // if the next event adds an infective, increment the number of infections
          } else if(pop_mat(j + 1, 2) == 3) {
                    num_rec += 1;             // if the next event is a recover, increment the number of recovery
          }

          }
          
          // return the vector of sufficient statistics for the rate parameters
          return Rcpp::NumericVector::create(num_exp, beta_suff, num_inf, gamma_suff, num_rec, mu_suff);
          }")

# MCMC transition kernel for the SIR model rate parameters and the binomial
# sampling probability. The prior distributions for the parameters are contained
# in this function.

gibbs_kernel <- function(epimodel) {
          
          # get sufficient statistics using the previously compiled getSuffStats function (above)
          suff_stats          <- getSuffStats(epimodel$pop_mat, epimodel$ind_final_config)
          
          # update parameters from their univariate full conditional distributions
          # Priors: beta  ~ gamma(0.006, 10)
          #         gamma ~ gamma(0.4, 1)
          #         mu    ~ gamma(1, 8)
          #         rho   ~ beta(5, 15)
          proposal          <- epimodel$params # params is the vector of ALL model parameters
          proposal["beta"]  <- rgamma(1, 0.006 + suff_stats[1], 1 + suff_stats[2])
          proposal["gamma"] <- rgamma(1, 0.4 + suff_stats[3], 1 + suff_stats[4])
          proposal["mu"]    <- rgamma(1, 1 + suff_stats[5], 6 + suff_stats[6])
          proposal["rho"]   <- rbeta(1, 
                                     shape1 = 5 + sum(epimodel$obs_mat[,"I_observed"]), 
                                     shape2 = 15 + sum(epimodel$obs_mat[,"I_augmented"]- epimodel$obs_mat[,"I_observed"]))
          
          # update array of rate matrices
          epimodel            <- build_new_irms(epimodel, proposal)
          
          # update the eigen decompositions
          buildEigenArray(real_eigenvals = epimodel$real_eigen_values,
                          imag_eigenvals = epimodel$imag_eigen_values,
                          eigenvecs      = epimodel$eigen_vectors, 
                          inversevecs    = epimodel$inv_eigen_vectors, 
                          irm_array      = epimodel$irm, 
                          n_real_eigs    = epimodel$n_real_eigs)

          # get log-likelihoods under the new parameters
          pop_likelihood_new  <- calc_pop_likelihood(epimodel, log = TRUE) #### NOTE - log = TRUE
          obs_likelihood_new  <- calc_obs_likelihood(epimodel, params = proposal, log = TRUE) #### NOTE - log = TRUE
          
          # update parameters, likelihood objects, and eigen decompositions
          epimodel            <- update_params(epimodel, params = proposal, pop_likelihood = pop_likelihood_new, obs_likelihood = obs_likelihood_new)
          
          return(epimodel)
}
```

We now re-initialize the epimodel object with the dataset, set the RNG seed, and run each MCMC chain as follows. Note that these commands were called within a script that varied the value of `chain`. 
```{r, warning = F, cache = T}
chain <- 1 # varies by chain. We used values of 1,2,3,4,6 (initial paths generated using initial values for 5 had zero probability under binomial emissions). this is set by a batch script.
set.seed(52787 + chain)

# initial values for initial state parameters
init_dist <- c(0.92, 0.015, 0.015, 0.05) + rnorm(4, 0, 1e-3); init_dist <- abs(init_dist) / sum(abs(init_dist))
epimodel  <- init_epimodel(popsize = 750,                                                       # population size
                          states = c("S", "E", "I", "R"),                                      # compartment names
                          params = c(beta = rnorm(1, 0.00075, 1e-4),                           # infectivity rate
                                     gamma = rnorm(1, 0.45, 0.1),                               # latent period rate
                                     mu = rnorm(1, 0.18, 0.1),                                  # recovery rate
                                     rho = rnorm(1, 0.2, .05),                                 # binomial sampling prob
                                     S0 = init_dist[1], E0 = init_dist[2], I0 = init_dist[3], R0 = init_dist[4]), 
                          rates = c("beta * I", "gamma", "mu"),                # unlumped transition rates
                          flow = matrix(c(-1, 1, 0, 0, 
                                          0, -1, 1, 0, 
                                          0, 0, -1, 1), ncol = 4, byrow = T),  # flow matrix
                          dat = dat,                                           # dataset
                          time_var = "time",                                   # name of time variable in the dataset
                          meas_vars = "I",                                     # name of measurement var in the dataset
                          initdist_prior = c(9, 0.15, 0.15, 0.5), ### Parameters for the dirichlet prior distribution for the initial state probs
                          r_meas_process = r_meas_process,
                          d_meas_process = d_meas_process)

epimodel <- init_settings(epimodel,
                          niter = 10, # this was set to 100,000 per chain for the paper
                          save_params_every = 1, 
                          save_configs_every = 5, # this was set to 250 for the chains run in the paper
                          kernel = list(gibbs_kernel),
                          configs_to_redraw = 10)

epimodel <- fit_epimodel(epimodel, monitor = FALSE)

```

After running all three chains for each prior regime, we discarded the first 1000 iterations of each chain as burn-in and combined the parameter samples and latent posterior samples from each chain. Posterior median estimates and 95% credible intervals of model parameters were computed, along with the pointwise posterior distribution of the latent process. These are presented in the paper and the supplement. 

## Analyzing an epidemic with SIRS dynamics
An epidemic with SIRS dynamics was simulated in a population of 750 individuals, of which 98% were initially susceptible, and 2% were initially infected. The per–contact infectivity rate was $\beta = 0.0005$ and the average infectious period was one week, $\mu = 1/7$, which together correspond to a basic reproduction number of $R_0 = \beta N / µ = 2.625$. The average duration of immunity was 120 days, $\gamma = 1/120$. Binomially sampled prevalence was observed at one week intervals over a period of six months with sampling probability $\rho=0.2$. 

This simulation aimed to establish that we could estimate the posterior distributions for the latent process and the model parameters. We set the following priors for the model parameters: $\beta\sim Gamma(0.0045, 10)$, $\mu\sim Gamma(1, 8)$, $\gamma \sim Gamma(0.08, 10)$, $\rho\sim Beta(5, 15)$, and $\mathbf{\mathrm{p}}_{t_1}\sim Dirichlet(9, 0.15, 0.01)$. 

The data are simulated as follows:

```{r, warning = F, cache = T}
library(BDAepimodel)
library(Rcpp)
library(coda)
set.seed(12511)

# declare the functions for simulating from and evaluating the log-density of the measurement process

r_meas_process <- function(state, meas_vars, params){
          # in our example, rho will be the name of the binomial sampling probability parameter.
          # this function returns a matrix of observed counts
          rbinom(n = nrow(state), 
                 size = state[,meas_vars],
                 prob = params["rho"])
}

d_meas_process <- function(state, meas_vars, params, log = TRUE) {
          # note that the names of the measurement variables are endowed with suffixes "_observed" and "_augmented". This is required.
          # we will declare the names of the measurement variables shortly.
          dbinom(x = state[, paste0(meas_vars, "_observed")], 
                 size = state[, paste0(meas_vars, "_augmented")], 
                 prob = params["rho"], log = log)
}

# initialize the stochastic epidemic model object
epimodel <- init_epimodel(obstimes = seq(1, 182, by = 7),                             # vector of observation times
                          popsize = 750,                                              # population size
                          states = c("S", "I", "R"),                                  # compartment names
                          params = c(beta = 0.00038,                                   # per-contact infectivity parameter
                                     mu = 1/9,                                        # recovery rate
                                     gamma = 1/180,                                   # loss of susceptibility param
                                     rho = 0.2,                                       # binomial sampling probability
                                     S0 = 0.98, I0 = 0.02, R0 = 0),      # initial state probabilities
                          rates = c("beta * I", "mu", "gamma"),                       # unlumped transition rates
                          flow = matrix(c(-1, 1, 0, 
                                          0, -1, 1, 
                                          1, 0, -1), ncol = 3, byrow = T),         # flow matrix
                          meas_vars = "I",                                            # name of measurement variable
                          r_meas_process = r_meas_process,                            # measurement process functions
                          d_meas_process = d_meas_process)

# simulate the epidemic and the dataset.  
epimodel <- simulate_epimodel(epimodel = epimodel, lump = TRUE, trim = TRUE)
plot(x = epimodel$pop_mat[,"time"], y = epimodel$pop_mat[,"I"], "l", ylim = c(-5, 200), xlab = "Time", ylab = "Prevalence")
points(x = epimodel$dat[,"time"], y = epimodel$dat[,"I"])
```

We grab the true latent path (for later comparison) along with the dataset. In order to perform inference, we will need a transition kernel for Gibbs updates of the rate parameters and the binomial sampling probability. One of the objectives of this simulation was to explore the sensitivity of the latent posterior distribution to the degree of prior information about model parameters. The code presented below displays the implementation for the case with informative parameters. We ran three chains, each for 250,000 MCMC iterations, updating 10 subject-paths per iteration. 

```{r, warning = F, cache = T}
# grab the data that was simulated previously. No need to redefine the measurement process functions, they remain unchanged.
true_path <- epimodel$pop_mat
dat <- epimodel$dat

# helper function for computing the sufficient statistics for the SIR model rate parameters
Rcpp::cppFunction("Rcpp::NumericVector getSuffStats(const Rcpp::NumericMatrix& pop_mat, const int ind_final_config) {
                  
          // initialize sufficient statistics
          int num_inf = 0;       // number of infectious events
          int num_rec = 0;       // number of recovery events
          int num_loss = 0;      // number of loss of immunity events
          double beta_suff  = 0; // integrated hazard for infections
          double mu_suff    = 0; // integrated hazard for the recovery
          double gamma_suff = 0; // integrated hazard for loss of immunity
          
          // initialize times
          double cur_time = 0;   // current time
          double next_time = 0;  // time of the next event
          
          // compute the sufficient statistics - loop through the pop_mat matrix until
          // reaching the row for the final observation time
          for(int j = 0; j < ind_final_config - 1; ++j) {

          cur_time = next_time;         
          next_time = pop_mat(j+1, 0); // grab the time of the next event
          
          beta_suff  += pop_mat(j, 3) * pop_mat(j, 4) * (next_time - cur_time); // add S*I*(t_{j+1} - t_j) to beta_suff
          mu_suff    += pop_mat(j, 4) * (next_time - cur_time);                 // add I*(t_{j+1} - t_j) to mu_suff
          gamma_suff += pop_mat(j, 5) * (next_time - cur_time);                 // add R*(t_{j+1} - t_j) to gamma_suff
          
          if(pop_mat(j + 1, 2) == 1) {  
                    num_inf += 1;             // if the next event is an infection, increment the number of infections
          } else if(pop_mat(j + 1, 2) == 2) {
                    num_rec += 1;             // if the next event is a recovery, increment the number of recoveries
          } else if(pop_mat(j + 1, 2) == 3) {
                    num_loss += 1;             // if the next event is a loss of immunity, increment that number
          }

          }
          
          // return the vector of sufficient statistics for the rate parameters
          return Rcpp::NumericVector::create(num_inf, beta_suff, num_rec, mu_suff, num_loss, gamma_suff);
          }")

# MCMC transition kernel for the SIR model rate parameters and the binomial
# sampling probability. The prior distributions for the parameters are contained
# in this function.

gibbs_kernel <- function(epimodel) {
          
          # get sufficient statistics using the previously compiled getSuffStats function (above)
          suff_stats          <- getSuffStats(epimodel$pop_mat, epimodel$ind_final_config)
          
          # update parameters from their univariate full conditional distributions
          # Priors: beta  ~ gamma(0.006, 10)
          #         gamma ~ gamma(0.4, 1)
          #         mu    ~ gamma(1, 8)
          #         rho   ~ beta(5, 15)
          proposal          <- epimodel$params # params is the vector of ALL model parameters
          proposal["beta"]  <- rgamma(1, 0.004 + suff_stats[1], 10 + suff_stats[2])
          proposal["mu"]    <- rgamma(1, 1 + suff_stats[3], 8.5 + suff_stats[4])
          proposal["gamma"] <- rgamma(1, 0.005 + suff_stats[5], 10 + suff_stats[6])
          proposal["rho"]   <- rbeta(1, 
                                     shape1 = 5 + sum(epimodel$obs_mat[,"I_observed"]), 
                                     shape2 = 15 + sum(epimodel$obs_mat[,"I_augmented"]- epimodel$obs_mat[,"I_observed"]))
          
          # update array of rate matrices
          epimodel            <- build_new_irms(epimodel, proposal)
          
          # update the eigen decompositions
          buildEigenArray(real_eigenvals = epimodel$real_eigen_values,
                          imag_eigenvals = epimodel$imag_eigen_values,
                          eigenvecs      = epimodel$eigen_vectors, 
                          inversevecs    = epimodel$inv_eigen_vectors, 
                          irm_array      = epimodel$irm, 
                          n_real_eigs    = epimodel$n_real_eigs)
      
          
          # get log-likelihoods under the new parameters
          pop_likelihood_new  <- calc_pop_likelihood(epimodel, log = TRUE) #### NOTE - log = TRUE
          obs_likelihood_new  <- calc_obs_likelihood(epimodel, params = proposal, log = TRUE) #### NOTE - log = TRUE
          
          # update parameters, likelihood objects, and eigen decompositions
          epimodel            <- update_params(epimodel, params = proposal, pop_likelihood = pop_likelihood_new, obs_likelihood = obs_likelihood_new)
          
          return(epimodel)
}
```

We now re-initialize the epimodel object with the dataset, set the RNG seed, and run each MCMC chain as follows. Note that these commands were called within a script that varied the value of `chain`. 
```{r, warning = F, cache = T}
chain <- 1 # varies by chain. obviously, chain 2 has a value of 2 here. this is set by a batch script.
set.seed(52787 + chain)

# initial values for initial state parameters
init_dist <- c(0.98, 0.015, 0.005) + rnorm(3, 0, 1e-3); init_dist <- abs(init_dist) / sum(abs(init_dist))
epimodel  <- init_epimodel(popsize = 750,                                                      # population size
                          states = c("S", "I", "R"),                                           # compartment names
                          params = c(beta = rnorm(1, 0.0004, 1e-4),                            # infectivity rate
                                     mu = rnorm(1, 0.1, 0.1),                                 # recovery rate
                                     gamma = rnorm(1, 1/180, 0.1e-3),                          # loss of immunity rate
                                     rho = rnorm(1, 0.2, .05),                                 # binomial sampling prob
                                     S0 = init_dist[1], I0 = init_dist[2], R0 = init_dist[3]), 
                          rates = c("beta * I", "mu", "gamma"),                # unlumped transition rates
                          flow = matrix(c(-1, 1, 0, 
                                          0, -1, 1,
                                          1, 0, -1), ncol = 3, byrow = T),  # flow matrix
                          dat = dat,                                           # dataset
                          time_var = "time",                                   # name of time variable in the dataset
                          meas_vars = "I",                                     # name of measurement var in the dataset
                          initdist_prior = c(9, 0.15, 0.01), ### Parameters for the dirichlet prior distribution for the initial state probs
                          r_meas_process = r_meas_process,
                          d_meas_process = d_meas_process)

epimodel <- init_settings(epimodel,
                          niter = 10, # this was set to 100,000 per chain for the paper
                          save_params_every = 1, 
                          save_configs_every = 5, # this was set to 250 for the chains run in the paper
                          kernel = list(gibbs_kernel),
                          configs_to_redraw = 10)

epimodel <- fit_epimodel(epimodel, monitor = FALSE)

```

After running all three chains for each prior regime, we discarded the first 1000 iterations of each chain as burn-in and combined the parameter samples and latent posterior samples from each chain. Posterior median estimates and 95% credible intervals of model parameters were computed, along with the pointwise posterior distribution of the latent process. These are presented in the paper and the supplement. 
