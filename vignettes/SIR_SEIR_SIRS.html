<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Jon Fintzi, Xiang Cui, Jon Wakefield, Vladimir Minin" />

<meta name="date" content="2017-02-15" />

<title>Implementing the SEIR, SIIR, and SIRS stochastic epidemic models in the BDAepimodel package</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>



<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%7D%0Apre%20%7B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%20code%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>




<h1 class="title toc-ignore">Implementing the SEIR, SIIR, and SIRS stochastic epidemic models in the BDAepimodel package</h1>
<h4 class="author"><em>Jon Fintzi, Xiang Cui, Jon Wakefield, Vladimir Minin</em></h4>
<h4 class="date"><em>2017-02-15</em></h4>



<p>This vignette contains code to reproduce the three stochastic epidemic models presented in the first simulation of Fintzi et al. (2016). We fit SIR, SEIR, and SIRS models to binomially distributed prevalence counts. Additional details on the use of the BDAepimodel package and how to extract the results from fitted objects are provided in the “BDAepimodel” vignette. Details on fitting the models in <code>pomp</code> are provided in the “SIR_SEIR_SIRS_pomp” vignette.</p>
<div id="analyzing-an-epidemic-with-sir-dynamics" class="section level2">
<h2>Analyzing an epidemic with SIR dynamics</h2>
<p>We simulated an epidemic with SIR dynamics in a population of 750 individuals, 90% of whom were initially susceptible, 3% of whom were initially infected, and 7% of whom were immune. The per–contact infectivity rate was <span class="math inline">\(\beta = 0.00035\)</span> and the average infectious period duration was $1/= 7 $ days, which together correspond to a basic reproduction number of <span class="math inline">\(R_0 = \beta N / µ = 1.84\)</span>. Binomially sampled prevalence was observed at one week intervals over a period of three months with sampling probability <span class="math inline">\(\rho=0.2\)</span>.</p>
<p>The data are simulated as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># set the seed for reproducibility!</span>
<span class="kw">set.seed</span>(<span class="dv">1834</span>)

<span class="co"># declare the functions for simulating from and evaluating the log-density of the measurement process</span>
r_meas_process &lt;-<span class="st"> </span>function(state, meas_vars, params){
          <span class="kw">rbinom</span>(<span class="dt">n =</span> <span class="kw">nrow</span>(state), 
                 <span class="dt">size =</span> state[,meas_vars], <span class="co"># binomial sample of the unobserved prevalenc</span>
                 <span class="dt">prob =</span> params[<span class="st">&quot;rho&quot;</span>])     <span class="co"># sampling probability</span>
}

d_meas_process &lt;-<span class="st"> </span>function(state, meas_vars, params, <span class="dt">log =</span> <span class="ot">TRUE</span>) {
          <span class="kw">dbinom</span>(<span class="dt">x =</span> state[, <span class="st">&quot;I_observed&quot;</span>], 
                 <span class="dt">size =</span> state[, <span class="st">&quot;I_augmented&quot;</span>], 
                 <span class="dt">prob =</span> params[<span class="st">&quot;rho&quot;</span>], <span class="dt">log =</span> log)
}

<span class="co"># initialize the stochastic epidemic model object</span>
epimodel &lt;-<span class="st"> </span><span class="kw">init_epimodel</span>(<span class="dt">obstimes =</span> <span class="kw">seq</span>(<span class="dv">0</span>, <span class="dv">105</span>, <span class="dt">by =</span> <span class="dv">7</span>),                             <span class="co"># vector of observation times</span>
                          <span class="dt">popsize =</span> <span class="dv">750</span>,                                              <span class="co"># population size</span>
                          <span class="dt">states =</span> <span class="kw">c</span>(<span class="st">&quot;S&quot;</span>, <span class="st">&quot;I&quot;</span>, <span class="st">&quot;R&quot;</span>),                                  <span class="co"># compartment names</span>
                          <span class="dt">params =</span> <span class="kw">c</span>(<span class="dt">beta =</span> <span class="fl">0.00035</span>,                                  <span class="co"># infectivity parameter</span>
                                     <span class="dt">mu =</span> <span class="dv">1</span>/<span class="dv">7</span>,                                        <span class="co"># recovery rate</span>
                                     <span class="dt">rho =</span> <span class="fl">0.2</span>,                                       <span class="co"># binomial sampling probability</span>
                                     <span class="dt">S0 =</span> <span class="fl">0.9</span>, <span class="dt">I0 =</span> <span class="fl">0.03</span>, <span class="dt">R0 =</span> <span class="fl">0.07</span>),                 <span class="co"># initial state probabilities</span>
                          <span class="dt">rates =</span> <span class="kw">c</span>(<span class="st">&quot;beta * I&quot;</span>, <span class="st">&quot;mu&quot;</span>),                                <span class="co"># unlumped transition rates</span>
                          <span class="dt">flow =</span> <span class="kw">matrix</span>(<span class="kw">c</span>(-<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, -<span class="dv">1</span>, <span class="dv">1</span>), <span class="dt">ncol =</span> <span class="dv">3</span>, <span class="dt">byrow =</span> T),  <span class="co"># flow matrix</span>
                          <span class="dt">meas_vars =</span> <span class="st">&quot;I&quot;</span>,                                            <span class="co"># name of measurement variable</span>
                          <span class="dt">r_meas_process =</span> r_meas_process,                            <span class="co"># measurement process functions</span>
                          <span class="dt">d_meas_process =</span> d_meas_process)

<span class="co"># simulate the epidemic and the dataset.  </span>
epimodel &lt;-<span class="st"> </span><span class="kw">simulate_epimodel</span>(<span class="dt">epimodel =</span> epimodel, <span class="dt">lump =</span> <span class="ot">TRUE</span>, <span class="dt">trim =</span> <span class="ot">TRUE</span>)

<span class="co"># plot the epidemic and the dataset</span>
<span class="kw">plot</span>(<span class="dt">x =</span> epimodel$pop_mat[,<span class="st">&quot;time&quot;</span>], <span class="dt">y =</span> epimodel$pop_mat[,<span class="st">&quot;I&quot;</span>], <span class="st">&quot;l&quot;</span>, <span class="dt">ylim =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">200</span>), <span class="dt">xlab =</span> <span class="st">&quot;Time&quot;</span>, <span class="dt">ylab =</span> <span class="st">&quot;Prevalence&quot;</span>)
<span class="kw">points</span>(<span class="dt">x =</span> epimodel$dat[,<span class="st">&quot;time&quot;</span>], <span class="dt">y =</span> epimodel$dat[,<span class="st">&quot;I&quot;</span>])</code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dat &lt;-<span class="st"> </span>epimodel$dat 
true_path &lt;-<span class="st"> </span>epimodel$pop_mat</code></pre></div>
<p>Having simulated a dataset, we can now proceed to fit an SIR model to the data. The first step is to define a transition kernel for the model parameters. We will update parameters from their univariate full conditional distributions via Gibbs sampling. We assign the following priors for the model parameters: <span class="math inline">\(\beta\sim Gamma(0.3, 1000)\)</span>, <span class="math inline">\(\mu\sim Gamma(1, 8)\)</span>, <span class="math inline">\(\rho\sim Beta(2, 7)\)</span>, and <span class="math inline">\(\mathbf{\mathrm{p}}_{t_1}\sim Dirichlet(90, 2, 5)\)</span>. The following code implements the transition kernel and a helper function for computing the sufficient statistics:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># helper function for computing the sufficient statistics for the SIR model rate parameters</span>
Rcpp::<span class="kw">cppFunction</span>(<span class="st">&quot;Rcpp::NumericVector getSuffStats_SIR(const Rcpp::NumericMatrix&amp; pop_mat, const int ind_final_config) {</span>
<span class="st">                  </span>
<span class="st">          // initialize sufficient statistics</span>
<span class="st">          int num_inf = 0;       // number of infection events</span>
<span class="st">          int num_rec = 0;       // number of recovery events</span>
<span class="st">          double beta_suff = 0;  // integrated hazard for the infectivity</span>
<span class="st">          double mu_suff = 0;    // integrated hazard for the recovery</span>

<span class="st">          // initialize times</span>
<span class="st">          double cur_time = 0;              // current time</span>
<span class="st">          double next_time = pop_mat(0,0);  // time of the first event</span>
<span class="st">          double dt = 0;                    // time increment</span>
<span class="st">          </span>
<span class="st">          // compute the sufficient statistics - loop through the pop_mat matrix until</span>
<span class="st">          // reaching the row for the final observation time</span>
<span class="st">          for(int j = 0; j &lt; ind_final_config - 1; ++j) {</span>
<span class="st">          </span>
<span class="st">                    cur_time = next_time;         </span>
<span class="st">                    next_time = pop_mat(j+1, 0); // grab the time of the next event</span>
<span class="st">                    dt = next_time - cur_time;   // compute the time increment</span>
<span class="st">                    </span>
<span class="st">                    beta_suff += pop_mat(j, 3) * pop_mat(j, 4) * dt; // add S*I*(t_{j+1} - t_j) to beta_suff</span>
<span class="st">                    mu_suff += pop_mat(j, 4) * dt;                   // add I*(t_{j+1} - t_j) to mu_suff</span>
<span class="st">                    </span>
<span class="st">                    // increment the count for the next event</span>
<span class="st">                    if(pop_mat(j + 1, 2) == 1) {  </span>
<span class="st">                              num_inf += 1;</span>
<span class="st">                    } else if(pop_mat(j + 1, 2) == 2) {</span>
<span class="st">                              num_rec += 1;</span>
<span class="st">                    }</span>
<span class="st">          }</span>
<span class="st">                  </span>
<span class="st">          // return the vector of sufficient statistics for the rate parameters</span>
<span class="st">          return Rcpp::NumericVector::create(num_inf, beta_suff, num_rec, mu_suff);</span>
<span class="st">}&quot;</span>)

<span class="co"># MCMC transition kernel for the SIR model rate parameters and the binomial</span>
<span class="co"># sampling probability. The prior distributions for the parameters are contained</span>
<span class="co"># in this function.</span>

gibbs_kernel_SIR &lt;-<span class="st"> </span>function(epimodel) {
          
          <span class="co"># get sufficient statistics using the previously compiled getSuffStats_SIR function (above)</span>
          suff_stats &lt;-<span class="st"> </span><span class="kw">getSuffStats_SIR</span>(epimodel$pop_mat, epimodel$ind_final_config)
          
          <span class="co"># update parameters from their univariate full conditional distributions</span>
          <span class="co"># Priors: beta ~ gamma(0.3, 1000)</span>
          <span class="co">#         mu   ~ gamma(1, 8)</span>
          <span class="co">#         rho  ~ beta(2, 7)</span>
          proposal          &lt;-<span class="st"> </span>epimodel$params <span class="co"># params is the vector of ALL model parameters</span>
          proposal[<span class="st">&quot;beta&quot;</span>]  &lt;-<span class="st"> </span><span class="kw">rgamma</span>(<span class="dv">1</span>, <span class="fl">0.3</span> +<span class="st"> </span>suff_stats[<span class="dv">1</span>], <span class="dv">1000</span> +<span class="st"> </span>suff_stats[<span class="dv">2</span>])
          proposal[<span class="st">&quot;mu&quot;</span>]    &lt;-<span class="st"> </span><span class="kw">rgamma</span>(<span class="dv">1</span>, <span class="dv">1</span> +<span class="st"> </span>suff_stats[<span class="dv">3</span>], <span class="dv">8</span> +<span class="st"> </span>suff_stats[<span class="dv">4</span>])
          proposal[<span class="st">&quot;rho&quot;</span>]   &lt;-<span class="st"> </span><span class="kw">rbeta</span>(<span class="dv">1</span>, <span class="dt">shape1 =</span> <span class="dv">2</span> +<span class="st"> </span><span class="kw">sum</span>(epimodel$obs_mat[, <span class="st">&quot;I_observed&quot;</span>]),
                                        <span class="dt">shape2 =</span> <span class="dv">7</span> +<span class="st"> </span><span class="kw">sum</span>(epimodel$obs_mat[, <span class="st">&quot;I_augmented&quot;</span>] -<span class="st"> </span>epimodel$obs_mat[, <span class="st">&quot;I_observed&quot;</span>]))
          
          <span class="co"># update array of rate matrices</span>
          epimodel &lt;-<span class="st"> </span><span class="kw">build_new_irms</span>(epimodel, proposal)
          
          <span class="co"># update the eigen decompositions (This function is built in and computes eigen decompositions analytically)</span>
          <span class="kw">buildEigenArray_SIR</span>(<span class="dt">real_eigenvals =</span> epimodel$real_eigen_values,
                              <span class="dt">imag_eigenvals =</span> epimodel$imag_eigen_values,
                              <span class="dt">eigenvecs      =</span> epimodel$eigen_vectors, 
                              <span class="dt">inversevecs    =</span> epimodel$inv_eigen_vectors, 
                              <span class="dt">irm_array      =</span> epimodel$irm, 
                              <span class="dt">n_real_eigs    =</span> epimodel$n_real_eigs, 
                              <span class="dt">initial_calc   =</span> <span class="ot">FALSE</span>)
          
          <span class="co"># get log-likelihood of the observations under the new parameters</span>
          obs_likelihood_new  &lt;-<span class="st"> </span><span class="kw">calc_obs_likelihood</span>(epimodel, <span class="dt">params =</span> proposal, <span class="dt">log =</span> <span class="ot">TRUE</span>) #### NOTE - log = TRUE
          
          <span class="co"># get the new population level CTMC log-likelihood</span>
          pop_likelihood_new  &lt;-<span class="st"> </span>epimodel$likelihoods$pop_likelihood_cur +
<span class="st">                    </span>suff_stats[<span class="dv">1</span>] *<span class="st"> </span>(<span class="kw">log</span>(proposal[<span class="st">&quot;beta&quot;</span>]) -<span class="st"> </span><span class="kw">log</span>(epimodel$params[<span class="st">&quot;beta&quot;</span>])) +
<span class="st">                    </span>suff_stats[<span class="dv">3</span>] *<span class="st"> </span>(<span class="kw">log</span>(proposal[<span class="st">&quot;mu&quot;</span>]) -<span class="st"> </span><span class="kw">log</span>(epimodel$params[<span class="st">&quot;mu&quot;</span>])) -
<span class="st">                    </span>suff_stats[<span class="dv">2</span>] *<span class="st"> </span>(proposal[<span class="st">&quot;beta&quot;</span>] -<span class="st"> </span>epimodel$params[<span class="st">&quot;beta&quot;</span>]) -<span class="st"> </span>
<span class="st">                    </span>suff_stats[<span class="dv">4</span>] *<span class="st"> </span>(proposal[<span class="st">&quot;mu&quot;</span>] -<span class="st"> </span>epimodel$params[<span class="st">&quot;mu&quot;</span>])
          
          <span class="co"># update parameters, likelihood objects, and eigen decompositions</span>
          epimodel  &lt;-
<span class="st">                    </span><span class="kw">update_params</span>(
                              epimodel,
                              <span class="dt">params =</span> proposal,
                              <span class="dt">pop_likelihood =</span> pop_likelihood_new,
                              <span class="dt">obs_likelihood =</span> obs_likelihood_new
                    )
          
          <span class="kw">return</span>(epimodel)
}</code></pre></div>
<p>We now re-initialize the epimodel object with the dataset, set the RNG seed, and run each MCMC chain as follows. Note that the chain was set by a batch script that varied the value of <code>chain</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">chain &lt;-<span class="st"> </span><span class="dv">1</span> <span class="co"># this was set by a batch script that ran chains 1, 2, and 3 in parallel</span>
<span class="kw">set.seed</span>(<span class="dv">52787</span> +<span class="st"> </span>chain)

<span class="co"># initial values for initial state parameters</span>
init_dist &lt;-<span class="st"> </span>MCMCpack::<span class="kw">rdirichlet</span>(<span class="dv">1</span>, <span class="kw">c</span>(<span class="dv">9</span>,<span class="fl">0.5</span>,<span class="fl">0.1</span>))
epimodel &lt;-<span class="st"> </span><span class="kw">init_epimodel</span>(<span class="dt">popsize =</span> <span class="dv">750</span>,                                                       <span class="co"># population size</span>
                          <span class="dt">states =</span> <span class="kw">c</span>(<span class="st">&quot;S&quot;</span>, <span class="st">&quot;I&quot;</span>, <span class="st">&quot;R&quot;</span>),                                           <span class="co"># compartment names</span>
                          <span class="dt">params =</span> <span class="kw">c</span>(<span class="dt">beta =</span> <span class="kw">abs</span>(<span class="kw">rnorm</span>(<span class="dv">1</span>, <span class="fl">0.00035</span>, <span class="fl">5e-5</span>)),                      <span class="co"># per-contact infectivity rate</span>
                                     <span class="dt">mu =</span> <span class="kw">abs</span>(<span class="kw">rnorm</span>(<span class="dv">1</span>, <span class="dv">1</span>/<span class="dv">7</span>, <span class="fl">0.02</span>)),                            <span class="co"># recovery rate</span>
                                     <span class="dt">rho =</span> <span class="kw">rbeta</span>(<span class="dv">1</span>, <span class="dv">21</span>, <span class="dv">75</span>),                                   <span class="co"># binomial sampling probability</span>
                                     <span class="dt">S0 =</span> init_dist[<span class="dv">1</span>], <span class="dt">I0 =</span> init_dist[<span class="dv">2</span>], <span class="dt">R0 =</span> init_dist[<span class="dv">3</span>]), <span class="co"># initial state probabilities</span>
                          <span class="dt">rates =</span> <span class="kw">c</span>(<span class="st">&quot;beta * I&quot;</span>, <span class="st">&quot;mu&quot;</span>),                                         <span class="co"># unlumped transition rates</span>
                          <span class="dt">flow =</span> <span class="kw">matrix</span>(<span class="kw">c</span>(-<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, -<span class="dv">1</span>, <span class="dv">1</span>), <span class="dt">ncol =</span> <span class="dv">3</span>, <span class="dt">byrow =</span> T),           <span class="co"># flow matrix</span>
                          <span class="dt">dat =</span> dat,                                                           <span class="co"># dataset</span>
                          <span class="dt">time_var =</span> <span class="st">&quot;time&quot;</span>,                                                   <span class="co"># name of time variable in the dataset</span>
                          <span class="dt">meas_vars =</span> <span class="st">&quot;I&quot;</span>,                                                     <span class="co"># name of measurement variable</span>
                          <span class="dt">initdist_prior =</span> <span class="kw">c</span>(<span class="dv">90</span>, <span class="dv">2</span>, <span class="dv">5</span>), ### Parameters for the dirichlet prior distribution for the initial state probs
                          <span class="dt">r_meas_process =</span> r_meas_process,
                          <span class="dt">d_meas_process =</span> d_meas_process)

epimodel &lt;-<span class="st"> </span><span class="kw">init_settings</span>(epimodel,
                          <span class="dt">niter =</span> <span class="dv">10</span>,  <span class="co"># this was set to 100,000 in the paper</span>
                          <span class="dt">save_params_every =</span> <span class="dv">1</span>, 
                          <span class="dt">save_configs_every =</span> <span class="dv">2</span>, <span class="co"># this was set to 250 in the paper </span>
                          <span class="dt">kernel =</span> <span class="kw">list</span>(gibbs_kernel_SIR),
                          <span class="dt">configs_to_redraw =</span> <span class="dv">1</span>, <span class="co"># this was set to 75 in the paper</span>
                          <span class="dt">analytic_eigen =</span> <span class="st">&quot;SIR&quot;</span>, <span class="co"># compute eigen decompositions and matrix inverses analytically</span>
                          <span class="dt">ecctmc_method =</span> <span class="st">&quot;mr&quot;</span>)   <span class="co"># sample subject paths in interevent intervals via modified rejection sampling</span>

epimodel &lt;-<span class="st"> </span><span class="kw">fit_epimodel</span>(epimodel, <span class="dt">monitor =</span> <span class="ot">FALSE</span>)</code></pre></div>
<pre><code>## [1] &quot;Initialization attempt 10&quot;
## [1] &quot;Configuration initialized. Beginning MCMC.&quot;</code></pre>
<p>After running all three chains for each prior regime, we discarded the first 10 iterations of each chain as burn-in and combined the parameter samples and latent posterior samples from each chain. Posterior median estimates and 95% credible intervals of model parameters were computed, along with the pointwise posterior distribution of the latent process. These are presented in the paper and the supplement.</p>
</div>
<div id="analyzing-an-epidemic-with-seir-dynamics" class="section level2">
<h2>Analyzing an epidemic with SEIR dynamics</h2>
<p>We simulated an epidemic with SEIR dynamics in a population of 500 individuals. The epidemic was initiated by a single infected individual in an otherwise completely suscpetible population. The per–contact infectivity rate was <span class="math inline">\(\beta = 0.000075\)</span>, the average incubation period was <span class="math inline">\(1/\gamma=14\)</span> days, and the average infectious period duration was $1/= 28 $ days, which together correspond to a basic reproduction number of <span class="math inline">\(R_0 = \beta N / µ = 1.05\)</span>. Binomially sampled prevalence was observed at one week intervals over a period of two years with sampling probability <span class="math inline">\(\rho=1/3\)</span>.</p>
<p>The data are simulated as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">1834</span>)

<span class="co"># declare the functions for simulating from and evaluating the log-density of the measurement process</span>
r_meas_process &lt;-<span class="st"> </span>function(state, meas_vars, params){
          <span class="kw">rbinom</span>(<span class="dt">n =</span> <span class="kw">nrow</span>(state), 
                 <span class="dt">size =</span> state[,meas_vars],
                 <span class="dt">prob =</span>  params[<span class="st">&quot;rho&quot;</span>])
}

d_meas_process &lt;-<span class="st"> </span>function(state, meas_vars, params, <span class="dt">log =</span> <span class="ot">TRUE</span>) {
          <span class="kw">dbinom</span>(<span class="dt">x =</span> state[, <span class="st">&quot;I_observed&quot;</span>], 
                 <span class="dt">size =</span> state[, <span class="st">&quot;I_augmented&quot;</span>],
                  <span class="dt">prob =</span> params[<span class="st">&quot;rho&quot;</span>], <span class="dt">log =</span> log)
}

<span class="co"># initialize the stochastic epidemic model object</span>
epimodel &lt;-<span class="st"> </span><span class="kw">init_epimodel</span>(<span class="dt">obstimes =</span> <span class="kw">seq</span>(<span class="dv">1</span>, <span class="dv">730</span>, <span class="dt">by =</span> <span class="dv">7</span>),                              <span class="co"># vector of observation times</span>
                          <span class="dt">popsize =</span> <span class="dv">500</span>,                                              <span class="co"># population size</span>
                          <span class="dt">states =</span> <span class="kw">c</span>(<span class="st">&quot;S&quot;</span>, <span class="st">&quot;E&quot;</span>, <span class="st">&quot;I&quot;</span>, <span class="st">&quot;R&quot;</span>),                             <span class="co"># compartment names</span>
                          <span class="dt">params =</span> <span class="kw">c</span>(<span class="dt">beta =</span> <span class="fl">0.000075</span>,                                   <span class="co"># per-contact infectivity parameter</span>
                                     <span class="dt">gamma =</span> <span class="dv">1</span>/<span class="dv">14</span>,                                    <span class="co"># latent period parameter</span>
                                     <span class="dt">mu =</span> <span class="dv">1</span>/<span class="dv">28</span>,                                       <span class="co"># recovery rate</span>
                                     <span class="dt">rho =</span> <span class="dv">1</span>/<span class="dv">3</span>,                                       <span class="co"># binomial sampling probability</span>
                                     <span class="dt">S0 =</span> <span class="fl">0.99</span>, <span class="dt">E0 =</span> <span class="fl">0.006</span>, <span class="dt">I0 =</span> <span class="fl">0.003</span>, <span class="dt">R0 =</span> <span class="fl">0.001</span>),      <span class="co"># initial state probabilities</span>
                          <span class="dt">rates =</span> <span class="kw">c</span>(<span class="st">&quot;beta * I&quot;</span>, <span class="st">&quot;gamma&quot;</span>, <span class="st">&quot;mu&quot;</span>),                       <span class="co"># unlumped transition rates</span>
                          <span class="dt">flow =</span> <span class="kw">matrix</span>(<span class="kw">c</span>(-<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, 
                                          <span class="dv">0</span>, -<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, 
                                          <span class="dv">0</span>, <span class="dv">0</span>, -<span class="dv">1</span>, <span class="dv">1</span>), <span class="dt">ncol =</span> <span class="dv">4</span>, <span class="dt">byrow =</span> T),         <span class="co"># flow matrix</span>
                          <span class="dt">meas_vars =</span> <span class="st">&quot;I&quot;</span>,                                            <span class="co"># name of measurement variable</span>
                          <span class="dt">r_meas_process =</span> r_meas_process,                            <span class="co"># measurement process functions</span>
                          <span class="dt">d_meas_process =</span> d_meas_process)

<span class="co"># simulate the epidemic and the dataset.  </span>
epimodel &lt;-<span class="st"> </span><span class="kw">simulate_epimodel</span>(<span class="dt">epimodel =</span> epimodel,
                              <span class="dt">init_state =</span> <span class="kw">c</span>(<span class="dt">S =</span> <span class="dv">499</span>, <span class="dt">E =</span> <span class="dv">0</span>, <span class="dt">I =</span> <span class="dv">1</span>, <span class="dt">R =</span> <span class="dv">0</span>),
                              <span class="dt">lump =</span> <span class="ot">TRUE</span>, 
                              <span class="dt">trim =</span> <span class="ot">TRUE</span>)

dat &lt;-<span class="st"> </span>epimodel$dat
true_path &lt;-<span class="st"> </span>epimodel$pop_mat

<span class="co"># plot the epidemic and the dataset</span>
<span class="kw">plot</span>(<span class="dt">x =</span> epimodel$pop_mat[,<span class="st">&quot;time&quot;</span>], <span class="dt">y =</span> epimodel$pop_mat[,<span class="st">&quot;I&quot;</span>], <span class="st">&quot;l&quot;</span>, <span class="dt">ylim =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">50</span>), <span class="dt">xlab =</span> <span class="st">&quot;Time&quot;</span>, <span class="dt">ylab =</span> <span class="st">&quot;Prevalence&quot;</span>)
<span class="kw">points</span>(<span class="dt">x =</span> epimodel$dat[,<span class="st">&quot;time&quot;</span>], <span class="dt">y =</span> epimodel$dat[,<span class="st">&quot;I&quot;</span>])</code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
<p>Having simulated a dataset, we can now proceed to fit an SEIR model to the data. The first step is to define a transition kernel for the model parameters. We will update parameters from their univariate full conditional distributions via Gibbs sampling. We assign the following priors for the model parameters: <span class="math inline">\(\beta\sim Gamma(1, 10000)\)</span>, <span class="math inline">\(\gamma \sim Gamma(1, 11)\)</span>, <span class="math inline">\(\mu\sim Gamma(3.2, 100)\)</span>, <span class="math inline">\(\rho\sim Beta(3.5, 6.5)\)</span>, and <span class="math inline">\(\mathbf{\mathrm{p}}_{t_1}\sim Dirichlet(100, 0.1, 0.4, 0.01)\)</span>. The following code implements the transition kernel and a helper function for computing the sufficient statistics:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">Rcpp::<span class="kw">cppFunction</span>(<span class="st">&quot;Rcpp::NumericVector getSuffStats_SEIR(const Rcpp::NumericMatrix&amp; pop_mat, const int ind_final_config) {</span>
<span class="st">                  </span>
<span class="st">          // initialize sufficient statistics</span>
<span class="st">          int num_exp = 0;       // number of exposure events</span>
<span class="st">          int num_inf = 0;       // number of exposed --&gt; infectious events</span>
<span class="st">          int num_rec = 0;       // number of recovery events</span>
<span class="st">          double beta_suff  = 0; // integrated hazard for the exposure</span>
<span class="st">          double gamma_suff = 0; // integrated hazard for addition of infectives</span>
<span class="st">          double mu_suff    = 0; // integrated hazard for the recovery</span>
<span class="st">          </span>
<span class="st">          // initialize times</span>
<span class="st">          double cur_time = 0;              // current time</span>
<span class="st">          double next_time = pop_mat(0,0);  // time of the first event</span>
<span class="st">          double dt = 0;                    // time increment</span>

<span class="st">          // compute the sufficient statistics - loop through the pop_mat matrix until</span>
<span class="st">          // reaching the row for the final observation time</span>
<span class="st">          for(int j = 0; j &lt; ind_final_config - 1; ++j) {</span>

<span class="st">                    cur_time = next_time;         </span>
<span class="st">                    next_time = pop_mat(j+1, 0); // grab the time of the next event</span>
<span class="st">                    dt = next_time - cur_time;</span>

<span class="st">                    beta_suff  += pop_mat(j, 3) * pop_mat(j, 5) * dt; // add S*I*(t_{j+1} - t_j) to beta_suff</span>
<span class="st">                    gamma_suff += pop_mat(j, 4) * dt;                 // add E*(t_{j+1} - t_j) to gamma_suff</span>
<span class="st">                    mu_suff    += pop_mat(j, 5) * dt;                 // add I*(t_{j+1} - t_j) to mu_suff</span>
<span class="st">                    </span>
<span class="st">                    if(pop_mat(j + 1, 2) == 1) {  </span>
<span class="st">                              num_exp += 1;            // if the next event is an exposure, increment the number of exposures</span>
<span class="st">                    } else if(pop_mat(j + 1, 2) == 2) {</span>
<span class="st">                              num_inf += 1;            // if the next event adds an infective, increment the number of infections</span>
<span class="st">                    } else if(pop_mat(j + 1, 2) == 3) {</span>
<span class="st">                              num_rec += 1;            // if the next event is a recover, increment the number of recovery</span>
<span class="st">                    }</span>
<span class="st">          }</span>
<span class="st">          </span>
<span class="st">          // return the vector of sufficient statistics for the rate parameters</span>
<span class="st">          return Rcpp::NumericVector::create(num_exp, beta_suff, num_inf, gamma_suff, num_rec, mu_suff);</span>
<span class="st">}&quot;</span>)

<span class="co"># MCMC transition kernel for the SIR model rate parameters and the binomial</span>
<span class="co"># sampling probability. The prior distributions for the parameters are contained</span>
<span class="co"># in this function.</span>

gibbs_kernel_SEIR &lt;-<span class="st"> </span>function(epimodel) {
          
          <span class="co"># get sufficient statistics using the previously compiled getSuffStats function (above)</span>
          suff_stats &lt;-<span class="st"> </span><span class="kw">getSuffStats_SEIR</span>(epimodel$pop_mat, epimodel$ind_final_config)
          
          <span class="co"># update parameters from their univariate full conditional distributions</span>
          <span class="co"># beta  ~ Gamma(1, 10000)</span>
          <span class="co"># gamma ~ Gamma(1, 11)</span>
          <span class="co"># mu    ~ Gamma(3.2, 100)</span>
          <span class="co"># rho   ~  Beta(3.5, 6.5)</span>
          <span class="co"># p_{t_1} ~ Dirichlet(100, 0.1, 0.4, 0.01)</span>
          proposal          &lt;-<span class="st"> </span>epimodel$params <span class="co"># params is the vector of ALL model parameters</span>
          proposal[<span class="st">&quot;beta&quot;</span>]  &lt;-<span class="st"> </span><span class="kw">rgamma</span>(<span class="dv">1</span>, <span class="dv">1</span> +<span class="st"> </span>suff_stats[<span class="dv">1</span>], <span class="dv">10000</span> +<span class="st"> </span>suff_stats[<span class="dv">2</span>])
          proposal[<span class="st">&quot;gamma&quot;</span>] &lt;-<span class="st"> </span><span class="kw">rgamma</span>(<span class="dv">1</span>, <span class="dv">1</span> +<span class="st"> </span>suff_stats[<span class="dv">3</span>], <span class="dv">11</span> +<span class="st"> </span>suff_stats[<span class="dv">4</span>])
          proposal[<span class="st">&quot;mu&quot;</span>]    &lt;-<span class="st"> </span><span class="kw">rgamma</span>(<span class="dv">1</span>, <span class="fl">3.2</span> +<span class="st"> </span>suff_stats[<span class="dv">5</span>], <span class="dv">100</span> +<span class="st"> </span>suff_stats[<span class="dv">6</span>])
          proposal[<span class="st">&quot;rho&quot;</span>]   &lt;-<span class="st"> </span><span class="kw">rbeta</span>(<span class="dv">1</span>, 
                                     <span class="dt">shape1 =</span> <span class="fl">3.5</span> +<span class="st"> </span><span class="kw">sum</span>(epimodel$obs_mat[,<span class="st">&quot;I_observed&quot;</span>]), 
                                     <span class="dt">shape2 =</span> <span class="fl">6.5</span> +<span class="st"> </span><span class="kw">sum</span>(epimodel$obs_mat[,<span class="st">&quot;I_augmented&quot;</span>]-<span class="st"> </span>epimodel$obs_mat[,<span class="st">&quot;I_observed&quot;</span>]))
          
          <span class="co"># update array of rate matrices</span>
          epimodel          &lt;-<span class="st"> </span><span class="kw">build_new_irms</span>(epimodel, proposal)
          
          <span class="co"># compute new eigendecompositions of CTMC rate matrices analytically</span>
          <span class="kw">buildEigenArray_SEIR</span>(<span class="dt">real_eigenvals =</span> epimodel$real_eigen_values,
                               <span class="dt">imag_eigenvals =</span> epimodel$imag_eigen_values,
                               <span class="dt">eigenvecs      =</span> epimodel$eigen_vectors, 
                               <span class="dt">inversevecs    =</span> epimodel$inv_eigen_vectors, 
                               <span class="dt">irm_array      =</span> epimodel$irm, 
                               <span class="dt">n_real_eigs    =</span> epimodel$n_real_eigs, 
                               <span class="dt">initial_calc   =</span> <span class="ot">FALSE</span>)
          
          <span class="co"># get the data log-likelihood under the new parameters</span>
          obs_likelihood_new &lt;-<span class="st"> </span><span class="kw">calc_obs_likelihood</span>(epimodel, <span class="dt">params =</span> proposal, <span class="dt">log =</span> <span class="ot">TRUE</span>) #### NOTE - log = TRUE
          
          <span class="co"># compute the new population level CTMC log-likelihood</span>
          pop_likelihood_new &lt;-<span class="st"> </span>epimodel$likelihoods$pop_likelihood_cur +
<span class="st">                    </span>suff_stats[<span class="dv">1</span>] *<span class="st"> </span>(<span class="kw">log</span>(proposal[<span class="st">&quot;beta&quot;</span>]) -<span class="st"> </span><span class="kw">log</span>(epimodel$params[<span class="st">&quot;beta&quot;</span>])) +<span class="st"> </span>
<span class="st">                    </span>suff_stats[<span class="dv">3</span>] *<span class="st"> </span>(<span class="kw">log</span>(proposal[<span class="st">&quot;gamma&quot;</span>]) -<span class="st"> </span><span class="kw">log</span>(epimodel$params[<span class="st">&quot;gamma&quot;</span>])) +
<span class="st">                    </span>suff_stats[<span class="dv">5</span>] *<span class="st"> </span>(<span class="kw">log</span>(proposal[<span class="st">&quot;mu&quot;</span>]) -<span class="st"> </span><span class="kw">log</span>(epimodel$params[<span class="st">&quot;mu&quot;</span>])) -
<span class="st">                    </span>suff_stats[<span class="dv">2</span>] *<span class="st"> </span>(proposal[<span class="st">&quot;beta&quot;</span>] -<span class="st"> </span>epimodel$params[<span class="st">&quot;beta&quot;</span>]) -<span class="st"> </span>
<span class="st">                    </span>suff_stats[<span class="dv">4</span>] *<span class="st"> </span>(proposal[<span class="st">&quot;gamma&quot;</span>] -<span class="st"> </span>epimodel$params[<span class="st">&quot;gamma&quot;</span>]) -<span class="st"> </span>
<span class="st">                    </span>suff_stats[<span class="dv">6</span>] *<span class="st"> </span>(proposal[<span class="st">&quot;mu&quot;</span>] -<span class="st"> </span>epimodel$params[<span class="st">&quot;mu&quot;</span>])
          
          <span class="co"># update parameters, likelihood objects, and eigen decompositions</span>
          epimodel &lt;-<span class="st"> </span><span class="kw">update_params</span>(epimodel,
                                    <span class="dt">params =</span> proposal,
                                    <span class="dt">pop_likelihood =</span> pop_likelihood_new,
                                    <span class="dt">obs_likelihood =</span> obs_likelihood_new
                    )
          
          <span class="kw">return</span>(epimodel)
}</code></pre></div>
<p>We now re-initialize the epimodel object with the dataset, set the RNG seed, and run each MCMC chain as follows. Note that the chain was set by a batch script that varied the value of <code>chain</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">chain &lt;-<span class="st"> </span><span class="dv">1</span> <span class="co"># this was set by a batch script that ran chains 1, 2, and 3 in parallel</span>
<span class="kw">set.seed</span>(<span class="dv">52787</span> +<span class="st"> </span>chain)

<span class="co"># initial values for initial state parameters</span>
init_dist &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">4</span>, <span class="kw">c</span>(<span class="fl">0.99</span>, <span class="fl">0.01</span>, <span class="fl">0.01</span>, <span class="fl">0.001</span>) , <span class="fl">1e-4</span>); init_dist &lt;-<span class="st"> </span><span class="kw">abs</span>(init_dist) /<span class="st"> </span><span class="kw">sum</span>(<span class="kw">abs</span>(init_dist))
epimodel  &lt;-<span class="st"> </span><span class="kw">init_epimodel</span>(<span class="dt">popsize =</span> <span class="dv">500</span>,                                                       <span class="co"># population size</span>
                           <span class="dt">states =</span> <span class="kw">c</span>(<span class="st">&quot;S&quot;</span>, <span class="st">&quot;E&quot;</span>, <span class="st">&quot;I&quot;</span>, <span class="st">&quot;R&quot;</span>),                                      <span class="co"># compartment names</span>
                           <span class="dt">params =</span> <span class="kw">c</span>(<span class="dt">beta =</span> <span class="kw">abs</span>(<span class="kw">rnorm</span>(<span class="dv">1</span>, <span class="fl">0.00008</span>, <span class="fl">1e-7</span>)),                           <span class="co"># infectivity rate</span>
                                      <span class="dt">gamma =</span> <span class="kw">abs</span>(<span class="kw">rnorm</span>(<span class="dv">1</span>, <span class="fl">0.08</span>, <span class="fl">0.01</span>)),                               <span class="co"># latent period rate</span>
                                      <span class="dt">mu =</span> <span class="kw">abs</span>(<span class="kw">rnorm</span>(<span class="dv">1</span>, <span class="fl">0.028</span>, <span class="fl">0.001</span>)),                                  <span class="co"># recovery rate</span>
                                      <span class="dt">rho =</span> <span class="kw">rbeta</span>(<span class="dv">1</span>, <span class="dv">30</span>, <span class="dv">75</span>),                                 <span class="co"># binomial sampling prob</span>
                                      <span class="dt">S0 =</span> init_dist[<span class="dv">1</span>], <span class="dt">E0 =</span> init_dist[<span class="dv">2</span>], <span class="dt">I0 =</span> init_dist[<span class="dv">3</span>], <span class="dt">R0 =</span> init_dist[<span class="dv">4</span>]),
                           <span class="dt">rates =</span> <span class="kw">c</span>(<span class="st">&quot;beta * I&quot;</span>, <span class="st">&quot;gamma&quot;</span>, <span class="st">&quot;mu&quot;</span>),                <span class="co"># unlumped transition rates</span>
                           <span class="dt">flow =</span> <span class="kw">matrix</span>(<span class="kw">c</span>(-<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>,
                                           <span class="dv">0</span>, -<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>,
                                           <span class="dv">0</span>, <span class="dv">0</span>, -<span class="dv">1</span>, <span class="dv">1</span>), <span class="dt">ncol =</span> <span class="dv">4</span>, <span class="dt">byrow =</span> T),  <span class="co"># flow matrix</span>
                           <span class="dt">dat =</span> dat,                                           <span class="co"># dataset</span>
                           <span class="dt">time_var =</span> <span class="st">&quot;time&quot;</span>,                                   <span class="co"># name of time variable in the dataset</span>
                           <span class="dt">meas_vars =</span> <span class="st">&quot;I&quot;</span>,                                     <span class="co"># name of measurement var in the dataset</span>
                           <span class="dt">initdist_prior =</span> <span class="kw">c</span>(<span class="dv">100</span>, <span class="fl">0.1</span>, <span class="fl">0.4</span>, <span class="fl">0.01</span>), ### Parameters for the dirichlet prior distribution for the initial state probs
                           <span class="dt">r_meas_process =</span> r_meas_process,
                           <span class="dt">d_meas_process =</span> d_meas_process)

epimodel &lt;-<span class="st"> </span><span class="kw">init_settings</span>(epimodel,
                          <span class="dt">niter =</span> <span class="dv">10</span>, <span class="co"># set to 100000 for the paper</span>
                          <span class="dt">save_params_every =</span> <span class="dv">1</span>, 
                          <span class="dt">save_configs_every =</span> <span class="dv">2</span>, <span class="co"># this was set to 250 for the chains run in the paper</span>
                          <span class="dt">kernel =</span> <span class="kw">list</span>(gibbs_kernel_SEIR),
                          <span class="dt">configs_to_redraw =</span> <span class="dv">1</span>, <span class="co"># this was set to 100 in the paper</span>
                          <span class="dt">analytic_eigen =</span> <span class="st">&quot;SEIR&quot;</span>, <span class="co"># compute eigen decompositions analytically</span>
                          <span class="dt">ecctmc_method =</span> <span class="st">&quot;unif&quot;</span>,  <span class="co"># sample paths in inter-event intervals via uniformization</span>
                          <span class="dt">seed =</span> <span class="dv">52787</span> +<span class="st"> </span>chain)

epimodel &lt;-<span class="st"> </span><span class="kw">fit_epimodel</span>(epimodel, <span class="dt">monitor =</span> <span class="ot">FALSE</span>)</code></pre></div>
<pre><code>## [1] &quot;Configuration initialized. Beginning MCMC.&quot;</code></pre>
<p>After running all three chains for each prior regime, we discarded the first 10 iterations of each chain as burn-in and combined the parameter samples and latent posterior samples from each chain. Posterior median estimates and 95% credible intervals of model parameters were computed, along with the pointwise posterior distribution of the latent process. These are presented in the paper and the supplement.</p>
</div>
<div id="analyzing-an-epidemic-with-sirs-dynamics" class="section level2">
<h2>Analyzing an epidemic with SIRS dynamics</h2>
<p>We simulated an epidemic with SIRS dynamics in a population of 200 individuals, 1% of whom were initially infected, with the rest being suscpetible. The per–contact infectivity rate was <span class="math inline">\(\beta = 0.0009\)</span>, the average infectious period duration was $1/= 14 $ days, and the average time until loss of immunity was <span class="math inline">\(1/\gamma = 150\)</span> days, which together correspond to a basic reproduction number of <span class="math inline">\(R_0 = \beta N / µ = 2.52\)</span>. Binomially sampled prevalence was observed at one week intervals over a period of one year with sampling probability <span class="math inline">\(\rho=0.8\)</span>.</p>
<p>The data are simulated as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">r_meas_process &lt;-<span class="st"> </span>function(state, meas_vars, params){
          <span class="co"># in our example, rho will be the name of the binomial sampling probability parameter.</span>
          <span class="co"># this function returns a matrix of observed counts</span>
          <span class="kw">rbinom</span>(<span class="dt">n =</span> <span class="kw">nrow</span>(state), 
                 <span class="dt">size =</span> state[,meas_vars],
                 <span class="dt">prob =</span> params[<span class="st">&quot;rho&quot;</span>])
}

d_meas_process &lt;-<span class="st"> </span>function(state, meas_vars, params, <span class="dt">log =</span> <span class="ot">TRUE</span>) {
          <span class="co"># note that the names of the measurement variables are endowed with suffixes &quot;_observed&quot; and &quot;_augmented&quot;. This is required.</span>
          <span class="co"># we will declare the names of the measurement variables shortly.</span>
          <span class="kw">dbinom</span>(<span class="dt">x =</span> state[, <span class="st">&quot;I_observed&quot;</span>], 
                 <span class="dt">size =</span> state[, <span class="st">&quot;I_augmented&quot;</span>],
                 <span class="dt">prob =</span> params[<span class="st">&quot;rho&quot;</span>], <span class="dt">log =</span> log)
}

<span class="co"># initialize the stochastic epidemic model object</span>
epimodel &lt;-<span class="st"> </span><span class="kw">init_epimodel</span>(<span class="dt">obstimes =</span> <span class="kw">seq</span>(<span class="dv">1</span>, <span class="dv">365</span>, <span class="dt">by =</span> <span class="dv">7</span>),                            <span class="co"># vector of observation times</span>
                          <span class="dt">popsize =</span> <span class="dv">200</span>,                                             <span class="co"># population size</span>
                          <span class="dt">states =</span> <span class="kw">c</span>(<span class="st">&quot;S&quot;</span>, <span class="st">&quot;I&quot;</span>, <span class="st">&quot;R&quot;</span>),                                 <span class="co"># compartment names</span>
                          <span class="dt">params =</span> <span class="kw">c</span>(<span class="dt">beta =</span> <span class="fl">0.0009</span>,                                  <span class="co"># per-contact infectivity parameter</span>
                                     <span class="dt">mu =</span> <span class="dv">1</span>/<span class="dv">14</span>,                                      <span class="co"># recovery rate</span>
                                     <span class="dt">gamma =</span> <span class="dv">1</span>/<span class="dv">150</span>,                                  <span class="co"># loss of susceptibility param</span>
                                     <span class="dt">rho =</span> <span class="fl">0.8</span>,                                      <span class="co"># binomial sampling probability</span>
                                     <span class="dt">S0 =</span> <span class="fl">0.99</span>, <span class="dt">I0 =</span> <span class="fl">0.01</span>, <span class="dt">R0 =</span> <span class="dv">0</span>),                  <span class="co"># initial state probabilities</span>
                          <span class="dt">rates =</span> <span class="kw">c</span>(<span class="st">&quot;beta * I&quot;</span>, <span class="st">&quot;mu&quot;</span>, <span class="st">&quot;gamma&quot;</span>),                      <span class="co"># unlumped transition rates</span>
                          <span class="dt">flow =</span> <span class="kw">matrix</span>(<span class="kw">c</span>(-<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, 
                                          <span class="dv">0</span>, -<span class="dv">1</span>, <span class="dv">1</span>, 
                                          <span class="dv">1</span>, <span class="dv">0</span>, -<span class="dv">1</span>), <span class="dt">ncol =</span> <span class="dv">3</span>, <span class="dt">byrow =</span> T),           <span class="co"># flow matrix</span>
                          <span class="dt">meas_vars =</span> <span class="st">&quot;I&quot;</span>,                                           <span class="co"># name of measurement variable</span>
                          <span class="dt">r_meas_process =</span> r_meas_process,                           <span class="co"># measurement process functions</span>
                          <span class="dt">d_meas_process =</span> d_meas_process)

<span class="co"># simulate the epidemic and the dataset.  </span>
epimodel &lt;-<span class="st"> </span><span class="kw">simulate_epimodel</span>(<span class="dt">epimodel =</span> epimodel, <span class="dt">lump =</span> <span class="ot">TRUE</span>, <span class="dt">trim =</span> <span class="ot">TRUE</span>)

<span class="co"># plot the epidemic and the dataset</span>
<span class="kw">plot</span>(<span class="dt">x =</span> epimodel$pop_mat[,<span class="st">&quot;time&quot;</span>], <span class="dt">y =</span> epimodel$pop_mat[,<span class="st">&quot;I&quot;</span>], <span class="st">&quot;l&quot;</span>, <span class="dt">ylim =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">100</span>), <span class="dt">xlab =</span> <span class="st">&quot;Time&quot;</span>, <span class="dt">ylab =</span> <span class="st">&quot;Prevalence&quot;</span>)
<span class="kw">points</span>(<span class="dt">x =</span> epimodel$dat[,<span class="st">&quot;time&quot;</span>], <span class="dt">y =</span> epimodel$dat[,<span class="st">&quot;I&quot;</span>])</code></pre></div>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASAAAAEgCAMAAAAjXV6yAAAATlBMVEUAAAAAACsAAFUAKysAK4AAVaorAAArACsrAFUrgNRVAABVACtVqqpVqv+AKwCA1P+qVQCq/6qq///UgCvU////qlX/1ID//6r//9T////v7DoYAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAIEUlEQVR4nO2dDXurJhiGOWdtzpKtbdbUpP7/P7oogsYGHkTgxeS51/W61rwBc4+PV0SjWuJFSR9A7VAQgIIAFASgIAAFASgIQEEACgJQEICCABQEoCAABQEoCEBBAAoCUBCAggAUBKAgAAUBKAhAQQAKAlAQgIIAFASgIAAFASgIQEEACgJQEICCABQEoCAABQEoCEBBAAoCUBCAggAUBKAgAAUBKAhAQQAKAlAQgIIAFASgIAAFASgIQEEACgJQEICCABQEoCAABQEoCEBBAAoCUBCAggAUBKAgAAUBKAhAQQAKAlAQgIIAFASgIEBiQWozSAlKW1w+KAhAQYDCgpZ3bWnYggAUBKAgAAUBKAhAQQAKAlAQgIIAFASgIAAFAWIEXQ7q5eu490V/v+tT0t+fa+uVJkJQ8+vj9PJ1OXgMndTwYqMcUQ8s6Pt9314FtSdn6+hDBrrIVfVKs1zQ5fDWf+zGLagLGXBFPbAg04KOjrbRPnsLGsagk3pzB9sXn3EM6mcxpX59+KL7kCvOVvbQgorWKw0X7QExgrrh2Tm4DCFKvfbJomugemRBevq6HF7dwf0sp167qOcbpE2S48mD+mm+6YfxJ5zmTZLjyaR7h1rgEyaKQ5Jz3rkHoeduQZ0blAfZMWiSU0fWK02maf6pZ7Gy9UoTIQguhiWtV5qYPGiVmaX1ShOTB3lz6NT1ShOfKBaqV5qYRNFzjpG+XmliFsx8S2XJ65UmpospzmJrAkWKywcFATJdWU1XrzR5rqwmrFeaLFdWU9YrTZYrq55SnmDRPuDKasp6pclzZTVhvdJkurKarl5pmAcBKAhAQYCFguyZKk9WowNFissHBQEiBJluxi7mCLym0KfX9rxjong/sDuNb7qTVd+pxjNvJO9OVs9/f/b/uki0kbwGi3Enq5d/PnyCUm0D3qagfiHouPd1sVQbyTcqqD2+djOZZxJL0oJU2y0aiTvKkwel2Ejer6rJL6xlShQTbCQ3K4/CimJmsTKXnitZnI1JFFcsl4WvSUc8AyoLcV2s6Y4bNyRPth0gaOxlkkSPQd/vvm3AcFEE1Ku91DBO52lBw+QV34IGQfpH1FBMJh0wBl0O3fy1SlCr/9meoMBZ7Hh1uE6Q/tUKD0L5FsyuJ6zRguzgbFqSHBl3d5x3f60QNMQo/Z+BB5mBnLs7rqPVKkGt2qSgErs7BiPbFLRqd0dYvWoUJD6PxbegjLs7hlPUwZLsCWv0GJRzd8eP2X1bgrLv7vh5AibYx2q8cKjULEAyV4wbg/LWa+f4MVbOUNwslrfemSDdnqRG6phBOvP9YsolSKQZxbSgvNtf1Pxyhj0n24igzPWq1p7HT2NVe9PJyqmqU9DsZbN8Nq4wVizo5LnXO6AUuBJ/T1BrWpDpaAU721JBJ/86WIJ6HddT1ZA/ll6nXihIJ0HenS+r673fvMxVROOoFAsF6SQowUTvE3T/r6b5mD5WyFF9gpx+zCg0THPPKuj+B1fT6X+yop+fbQhSk59bWdmpT5Drj8MIbUyVyqwXC4IXlVfW6xRkh6F2Mg7lH4tqy6QdH3hMHkdNY4adk8oEOT/wRNw4TpcwVJcgx3nGPGre1+7HpOmAWxQ0xCplRuubPyp7SpJkF2hVguZLZbiI2UKand6sptUHXpMg5RmDXGXcdKSpG3Ny+ziCJp8puBBlJ7ObVjO2nfUjkbSg6YgRNWYMHc32rGkaaX9WHH0mQWF3+5gT83Z0FCNo4mccm2etKopFn3vRgYfd7aPa2wE17tqOXSS6sTJWc6dBBf4smFKXBLah92qMqbA5nLjBYjLi/DjMUVAb/xN4GAsO2X23z/R/sbo5/jWXBqeS770UST5BwS3ItJphwl5Qxay0Wc/68VJlLSjwbp8xj8m9dGGbWCVjUOjdPpm1TKuL7GPyeVD1iAnaDEKCFhcqHlqwqKhCxUMLFhVVqHhowaKiChUPLVhUVKHioQWLiipUPLRgUVGFiocWLCqqUPHQgkVFFSoeWrCox4SCABQEoCAABQEoCEBBAAoCUBCAggAUBKAgAAUB0gtqAm6+H56HakNd7+m32+yDQrs73mYRIUcCSS6o+ybfBhzX5aC/D9mEut7z/X7946l7aBgM7R/KchsRciSY1IL0Boej92lWjd6BZUOd79G3+F0/Og7tH+vTfQ0hDl1GakH2M7lDGrXvd8/YUPCeaysIDO0EhZYaSnJBf7o2jW6L0YJMKHjPcRLhD+1vLA0sNZTUgnSnR12/P2wb6n9Pt9UmKLTpx/PAUoOpXlBjxuiAT/39/vJVu6DUXUxv1QrtN91wVXkXCxsagwfp0/TZn3jkvb5c+yAdNrk2YdO83fMXmhE0IRnBMkQSxaHhw5TuvDNbIXH21z17rXdSeaI4Sfk9DCODDXW856Q3g3UvoVD9POy3kFKXwZNVAAUBKAhAQQAKAlAQgIIAFASgIAAFASgIQEEACgJQEICCABQEoCAABQEoCEBBAAoCUBCAggAUBKAgAAUBKAhQnaDxG2L+S/JtQ2upTlCH3vtUBxQEqFhQ99C98+7fa5fbn3d6a8vJbLwvR/WC+r32vz/7vXT6+2PKGqpe0L41v970l+Qm+R60cKoX9NbaX3o/XYqvIFrApgQNCQAFeVtQYbYkKM33VC5kS4L6Waw9lm1HmxLU50FlJ7E6BdUEBQEoCEBBAAoCUBCAggAUBKAgAAUBKAhAQQAKAlAQgIIAFASgIAAFASgIQEEACgJQEICCABQE+B/A47WWQPcR1AAAAABJRU5ErkJggg==" /><!-- --></p>
<p>Having simulated a dataset, we can now proceed to fit an SIRS model to the data. The first step is to define a transition kernel for the model parameters. We will update parameters from their univariate full conditional distributions via Gibbs sampling. We assign the following priors for the model parameters: <span class="math inline">\(\beta\sim Gamma(0.1, 100)\)</span>, <span class="math inline">\(\mu\sim Gamma(1.8, 14)\)</span>, <span class="math inline">\(\gamma \sim Gamma(0.0625, 10)\)</span>, <span class="math inline">\(\rho\sim Beta(5, 1)\)</span>, and <span class="math inline">\(\mathbf{\mathrm{p}}_{t_1}\sim Dirichlet(90, 1.5, 0.01)\)</span>. The following code implements the transition kernel and a helper function for computing the sufficient statistics:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># helper function for computing the sufficient statistics for the SIR model rate parameters</span>
Rcpp::<span class="kw">cppFunction</span>(<span class="st">&quot;Rcpp::NumericVector getSuffStats_SIRS(const Rcpp::NumericMatrix&amp; pop_mat, const int ind_final_config) {</span>
<span class="st">                  </span>
<span class="st">          // initialize sufficient statistics</span>
<span class="st">          int num_inf = 0;       // number of infectious events</span>
<span class="st">          int num_rec = 0;       // number of recovery events</span>
<span class="st">          int num_loss = 0;      // number of loss of immunity events</span>
<span class="st">          double beta_suff  = 0; // integrated hazard for infections</span>
<span class="st">          double mu_suff    = 0; // integrated hazard for the recovery</span>
<span class="st">          double gamma_suff = 0; // integrated hazard for loss of immunity</span>
<span class="st">          </span>
<span class="st">          // initialize times</span>
<span class="st">          double cur_time = 0;              // current time</span>
<span class="st">          double next_time = pop_mat(0,0);  // time of the first event</span>
<span class="st">          double dt = 0;                    // time increment</span>
<span class="st">          </span>
<span class="st">          // compute the sufficient statistics - loop through the pop_mat matrix until</span>
<span class="st">          // reaching the row for the final observation time</span>
<span class="st">          for(int j = 0; j &lt; ind_final_config - 1; ++j) {</span>
<span class="st">          </span>
<span class="st">                    cur_time = next_time;         </span>
<span class="st">                    next_time = pop_mat(j+1, 0); // grab the time of the next event</span>
<span class="st">                    dt = next_time - cur_time;   // compute the time increment</span>
<span class="st">                    </span>
<span class="st">                    beta_suff  += pop_mat(j, 3) * pop_mat(j, 4) * dt; // add S*I*(t_{j+1} - t_j) to beta_suff</span>
<span class="st">                    mu_suff    += pop_mat(j, 4) * dt;                 // add I*(t_{j+1} - t_j) to mu_suff</span>
<span class="st">                    gamma_suff += pop_mat(j, 5) * dt;                 // add R*(t_{j+1} - t_j) to gamma_suff</span>
<span class="st">                    </span>
<span class="st">                    if(pop_mat(j + 1, 2) == 1) {  </span>
<span class="st">                              num_inf += 1;             // if the next event is an infection, increment the number of infections</span>
<span class="st">                    } else if(pop_mat(j + 1, 2) == 2) {</span>
<span class="st">                              num_rec += 1;             // if the next event is a recovery, increment the number of recoveries</span>
<span class="st">                    } else if(pop_mat(j + 1, 2) == 3) {</span>
<span class="st">                              num_loss += 1;             // if the next event is a loss of immunity, increment that number</span>
<span class="st">                    }</span>
<span class="st">          }</span>
<span class="st">          </span>
<span class="st">          // return the vector of sufficient statistics for the rate parameters</span>
<span class="st">          return Rcpp::NumericVector::create(num_inf, beta_suff, num_rec, mu_suff, num_loss, gamma_suff);</span>
<span class="st">}&quot;</span>)

<span class="co"># MCMC transition kernel for the SIR model rate parameters and the binomial</span>
<span class="co"># sampling probability. The prior distributions for the parameters are contained</span>
<span class="co"># in this function.</span>

gibbs_kernel_SIRS &lt;-<span class="st"> </span>function(epimodel) {
          
          <span class="co"># get sufficient statistics using the previously compiled getSuffStats function (above)</span>
          suff_stats          &lt;-<span class="st"> </span><span class="kw">getSuffStats_SIRS</span>(epimodel$pop_mat, epimodel$ind_final_config)
          
          <span class="co"># update parameters from their univariate full conditional distributions</span>
          <span class="co"># beta  ~ Gamma(0.1, 100)</span>
          <span class="co"># gamma ~ Gamma(1.8, 14)</span>
          <span class="co"># mu    ~ Gamma(0.0625, 10)</span>
          <span class="co"># rho   ~  Beta(5, 1)</span>
          <span class="co"># p_{t_1} ~ Dirichlet(90, 1.5, 0.01)</span>
          proposal          &lt;-<span class="st"> </span>epimodel$params <span class="co"># params is the vector of ALL model parameters</span>
          proposal[<span class="st">&quot;beta&quot;</span>]  &lt;-<span class="st"> </span><span class="kw">rgamma</span>(<span class="dv">1</span>, <span class="fl">0.1</span> +<span class="st"> </span>suff_stats[<span class="dv">1</span>], <span class="dv">100</span> +<span class="st"> </span>suff_stats[<span class="dv">2</span>])
          proposal[<span class="st">&quot;mu&quot;</span>]    &lt;-<span class="st"> </span><span class="kw">rgamma</span>(<span class="dv">1</span>, <span class="fl">1.8</span> +<span class="st"> </span>suff_stats[<span class="dv">3</span>], <span class="dv">14</span> +<span class="st"> </span>suff_stats[<span class="dv">4</span>])
          proposal[<span class="st">&quot;gamma&quot;</span>] &lt;-<span class="st"> </span><span class="kw">rgamma</span>(<span class="dv">1</span>, <span class="fl">0.0625</span> +<span class="st"> </span>suff_stats[<span class="dv">5</span>], <span class="dv">10</span> +<span class="st"> </span>suff_stats[<span class="dv">6</span>])
          proposal[<span class="st">&quot;rho&quot;</span>]   &lt;-<span class="st"> </span><span class="kw">rbeta</span>(<span class="dv">1</span>, 
                                     <span class="dt">shape1 =</span> <span class="dv">5</span> +<span class="st"> </span><span class="kw">sum</span>(epimodel$obs_mat[,<span class="st">&quot;I_observed&quot;</span>]), 
                                     <span class="dt">shape2 =</span> <span class="dv">1</span> +<span class="st"> </span><span class="kw">sum</span>(epimodel$obs_mat[,<span class="st">&quot;I_augmented&quot;</span>]-<span class="st"> </span>epimodel$obs_mat[,<span class="st">&quot;I_observed&quot;</span>]))
          
          <span class="co"># update array of rate matrices</span>
          epimodel &lt;-<span class="st"> </span><span class="kw">build_new_irms</span>(epimodel, proposal)
          
          <span class="co"># compute the eigen decompositions numerically</span>
          <span class="kw">buildEigenArray</span>(<span class="dt">real_eigenvals =</span> epimodel$real_eigen_values,
                               <span class="dt">imag_eigenvals =</span> epimodel$imag_eigen_values,
                               <span class="dt">eigenvecs      =</span> epimodel$eigen_vectors,
                               <span class="dt">inversevecs    =</span> epimodel$inv_eigen_vectors,
                               <span class="dt">irm_array      =</span> epimodel$irm,
                               <span class="dt">n_real_eigs    =</span> epimodel$n_real_eigs)
          
          <span class="co"># get log-likelihoods under the new parameters</span>
          obs_likelihood_new &lt;-<span class="st"> </span><span class="kw">calc_obs_likelihood</span>(epimodel, <span class="dt">params =</span> proposal, <span class="dt">log =</span> <span class="ot">TRUE</span>) #### NOTE - log = TRUE
          
          <span class="co"># compute the new population level CTMC log-likelihood</span>
          pop_likelihood_new &lt;-<span class="st"> </span>epimodel$likelihoods$pop_likelihood_cur +
<span class="st">                    </span>suff_stats[<span class="dv">1</span>] *<span class="st"> </span>(<span class="kw">log</span>(proposal[<span class="st">&quot;beta&quot;</span>]) -<span class="st"> </span><span class="kw">log</span>(epimodel$params[<span class="st">&quot;beta&quot;</span>])) +<span class="st"> </span>
<span class="st">                    </span>suff_stats[<span class="dv">3</span>] *<span class="st"> </span>(<span class="kw">log</span>(proposal[<span class="st">&quot;mu&quot;</span>]) -<span class="st"> </span><span class="kw">log</span>(epimodel$params[<span class="st">&quot;mu&quot;</span>])) +
<span class="st">                    </span>suff_stats[<span class="dv">5</span>] *<span class="st"> </span>(<span class="kw">log</span>(proposal[<span class="st">&quot;gamma&quot;</span>]) -<span class="st"> </span><span class="kw">log</span>(epimodel$params[<span class="st">&quot;gamma&quot;</span>])) -
<span class="st">                    </span>suff_stats[<span class="dv">2</span>] *<span class="st"> </span>(proposal[<span class="st">&quot;beta&quot;</span>] -<span class="st"> </span>epimodel$params[<span class="st">&quot;beta&quot;</span>]) -<span class="st"> </span>
<span class="st">                    </span>suff_stats[<span class="dv">4</span>] *<span class="st"> </span>(proposal[<span class="st">&quot;mu&quot;</span>] -<span class="st"> </span>epimodel$params[<span class="st">&quot;mu&quot;</span>]) -<span class="st"> </span>
<span class="st">                    </span>suff_stats[<span class="dv">6</span>] *<span class="st"> </span>(proposal[<span class="st">&quot;gamma&quot;</span>] -<span class="st"> </span>epimodel$params[<span class="st">&quot;gamma&quot;</span>])  
          
          <span class="co"># update parameters, likelihood objects, and eigen decompositions</span>
          epimodel &lt;-<span class="st"> </span><span class="kw">update_params</span>(epimodel,
                                    <span class="dt">params =</span> proposal,
                                    <span class="dt">pop_likelihood =</span> pop_likelihood_new,
                                    <span class="dt">obs_likelihood =</span> obs_likelihood_new
                    )
          
          <span class="kw">return</span>(epimodel)
}</code></pre></div>
<p>We now re-initialize the epimodel object with the dataset, set the RNG seed, and run each MCMC chain as follows. Note that the chain was set by a batch script that varied the value of <code>chain</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">chain &lt;-<span class="st"> </span><span class="dv">1</span> <span class="co"># this was set by a batch script that ran chains 1, 2, and 3 in parallel</span>

init_dist &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">rnorm</span>(<span class="dv">3</span>, <span class="kw">c</span>(<span class="fl">0.98</span>, <span class="fl">0.01</span>, <span class="fl">0.001</span>), <span class="fl">1e-5</span>)); init_dist &lt;-<span class="st"> </span><span class="kw">abs</span>(init_dist) /<span class="st"> </span><span class="kw">sum</span>(<span class="kw">abs</span>(init_dist))
epimodel  &lt;-<span class="st"> </span><span class="kw">init_epimodel</span>(<span class="dt">popsize =</span> <span class="dv">200</span>,                                                    <span class="co"># population size</span>
                           <span class="dt">states =</span> <span class="kw">c</span>(<span class="st">&quot;S&quot;</span>, <span class="st">&quot;I&quot;</span>, <span class="st">&quot;R&quot;</span>),                                        <span class="co"># compartment names</span>
                           <span class="dt">params =</span> <span class="kw">c</span>(<span class="dt">beta =</span> <span class="kw">abs</span>(<span class="kw">rnorm</span>(<span class="dv">1</span>, <span class="fl">0.00077</span>, <span class="fl">1e-4</span>)),                   <span class="co"># infectivity rate</span>
                                      <span class="dt">mu =</span> <span class="kw">abs</span>(<span class="kw">rnorm</span>(<span class="dv">1</span>, <span class="dv">1</span>/<span class="dv">18</span>, <span class="fl">1e-4</span>)),                        <span class="co"># recovery rate</span>
                                      <span class="dt">gamma =</span> <span class="kw">abs</span>(<span class="kw">rnorm</span>(<span class="dv">1</span>, <span class="dv">1</span>/<span class="dv">140</span>, <span class="fl">0.1e-4</span>)),                  <span class="co"># loss of immunity rate</span>
                                      <span class="dt">rho =</span> <span class="kw">rbeta</span>(<span class="dv">1</span>, <span class="dv">22</span>, <span class="dv">5</span>),                                 <span class="co"># binomial sampling prob</span>
                                      <span class="dt">S0 =</span> init_dist[<span class="dv">1</span>], <span class="dt">I0 =</span> init_dist[<span class="dv">2</span>], <span class="dt">R0 =</span> init_dist[<span class="dv">3</span>]), 
                           <span class="dt">rates =</span> <span class="kw">c</span>(<span class="st">&quot;beta * I&quot;</span>, <span class="st">&quot;mu&quot;</span>, <span class="st">&quot;gamma&quot;</span>),                <span class="co"># unlumped transition rates</span>
                           <span class="dt">flow =</span> <span class="kw">matrix</span>(<span class="kw">c</span>(-<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, 
                                           <span class="dv">0</span>, -<span class="dv">1</span>, <span class="dv">1</span>,
                                           <span class="dv">1</span>, <span class="dv">0</span>, -<span class="dv">1</span>), <span class="dt">ncol =</span> <span class="dv">3</span>, <span class="dt">byrow =</span> T),  <span class="co"># flow matrix</span>
                           <span class="dt">dat =</span> dat,                                        <span class="co"># dataset</span>
                           <span class="dt">time_var =</span> <span class="st">&quot;time&quot;</span>,                                <span class="co"># name of time variable in the dataset</span>
                           <span class="dt">meas_vars =</span> <span class="st">&quot;I&quot;</span>,                                  <span class="co"># name of measurement var in the dataset</span>
                           <span class="dt">initdist_prior =</span> <span class="kw">c</span>(<span class="dv">90</span>, <span class="fl">1.5</span>, <span class="fl">0.01</span>),                <span class="co"># Prior for the initial state probs</span>
                           <span class="dt">r_meas_process =</span> r_meas_process,
                           <span class="dt">d_meas_process =</span> d_meas_process)

epimodel &lt;-<span class="st"> </span><span class="kw">init_settings</span>(epimodel,
                          <span class="dt">niter =</span> <span class="dv">10</span>, <span class="co"># this was set to 300000 per chain for the paper</span>
                          <span class="dt">save_params_every =</span> <span class="dv">1</span>, 
                          <span class="dt">save_configs_every =</span> <span class="dv">2</span>, <span class="co"># this was set to 1000 for the chains run in the paper</span>
                          <span class="dt">kernel =</span> <span class="kw">list</span>(gibbs_kernel_SIRS),
                          <span class="dt">configs_to_redraw =</span> <span class="dv">3</span>,
                          <span class="dt">ecctmc_method =</span> <span class="st">&quot;unif&quot;</span>, <span class="co"># sample paths in inter-event intervals via uniformization</span>
                          <span class="dt">seed =</span> <span class="dv">52787</span> +<span class="st"> </span>chain)

epimodel &lt;-<span class="st"> </span><span class="kw">fit_epimodel</span>(epimodel, <span class="dt">monitor =</span> <span class="ot">FALSE</span>)</code></pre></div>
<pre><code>## [1] &quot;Initialization attempt 10&quot;
## [1] &quot;Configuration initialized. Beginning MCMC.&quot;</code></pre>
<p>After running all three chains for each prior regime, we discarded the first 10 iterations of each chain as burn-in and combined the parameter samples and latent posterior samples from each chain. Posterior median estimates and 95% credible intervals of model parameters were computed, along with the pointwise posterior distribution of the latent process. These are presented in the paper and the supplement.</p>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
