<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Jon Fintzi, Xiang Cui, Jon Wakefield, Vladimir Minin" />

<meta name="date" content="2017-05-12" />

<title>Fitting misspecified SIR and SEIR stochastic epidemic models</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>



<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%7D%0Apre%20%7B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%20code%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>




<h1 class="title toc-ignore">Fitting misspecified SIR and SEIR stochastic epidemic models</h1>
<h4 class="author"><em>Jon Fintzi, Xiang Cui, Jon Wakefield, Vladimir Minin</em></h4>
<h4 class="date"><em>2017-05-12</em></h4>



<p>This vignette contains code to reproduce the simulation examining the effects of model misspecfication presented in the second simulation of Fintzi et al. (2016). We fit SIR and SEIR models to binomially distributed prevalence counts sampled from an epidemic with time-varying dynamics. Additional details on the use of the BDAepimodel package and how to extract the results from fitted objects are provided in the “BDAepimodel” vignette. Details on fitting the models in pomp are provided in the “model_misspecification_pomp” vignette.</p>
<div id="simualting-the-epidemic" class="section level2">
<h2>Simualting the epidemic</h2>
<p>We simulated an epidemic with SEIR dynamics in a population of 400 individuals, 397 of whom were initially susceptible, 2 of whom were initially exposed, and 1 of whom were initially infectious. The dynamics of the epidemic varied over four different epochs and are presented in the table below:</p>
<table>
<caption>Time varying dynamics. Effective reproductive numbers are computed as the product of the per-contact infectivity rate, the mean infectious period, and the number of susceptibles at the beginning of the epoch.</caption>
<thead>
<tr class="header">
<th></th>
<th align="right">Epoch 1</th>
<th align="right">Epoch 2</th>
<th align="right">Epoch 3</th>
<th align="right">Epoch 4</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Effective.R0</td>
<td align="right">14.9</td>
<td align="right">9.2</td>
<td align="right">0.1</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td>Incubation.period</td>
<td align="right">210.0</td>
<td align="right">210.0</td>
<td align="right">90.0</td>
<td align="right">180</td>
</tr>
<tr class="odd">
<td>Infectious.period</td>
<td align="right">150.0</td>
<td align="right">330.0</td>
<td align="right">300.0</td>
<td align="right">70</td>
</tr>
</tbody>
</table>
<p>The data are simulated as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">1834</span>)

<span class="co"># declare the functions for simulating from and evaluating the log-density of the measurement process</span>
r_meas_process &lt;-<span class="st"> </span>function(state, meas_vars, params){
          <span class="co"># in our example, rho will be the name of the binomial sampling probability parameter.</span>
          <span class="co"># this function returns a matrix of observed counts</span>
          <span class="kw">rbinom</span>(<span class="dt">n =</span> <span class="kw">nrow</span>(state),
                 <span class="dt">size =</span> state[,meas_vars],
                 <span class="dt">prob =</span>  params[<span class="st">&quot;rho&quot;</span>])
}

<span class="co"># initialize the stochastic epidemic model object</span>
epimodel &lt;-<span class="st"> </span><span class="kw">init_epimodel</span>(<span class="dt">obstimes =</span> <span class="kw">seq</span>(<span class="dv">1</span>, <span class="dv">183</span>, <span class="dt">by =</span> <span class="dv">7</span>),                    <span class="co"># vector of observation times</span>
                          <span class="dt">popsize =</span> <span class="dv">400</span>,                                      <span class="co"># population size</span>
                          <span class="dt">states =</span> <span class="kw">c</span>(<span class="st">&quot;S&quot;</span>, <span class="st">&quot;E&quot;</span>, <span class="st">&quot;I&quot;</span>, <span class="st">&quot;R&quot;</span>),                <span class="co"># compartment names</span>
                          <span class="dt">params =</span> <span class="kw">c</span>(<span class="dt">beta =</span> <span class="fl">0.00025</span>,                     <span class="co"># per-contact infectivity parameter high</span>
                                     <span class="dt">gamma =</span> <span class="dv">1</span>/<span class="dv">210</span>,                      <span class="co"># exposed compartment</span>
                                     <span class="dt">mu =</span> <span class="dv">1</span>/<span class="dv">150</span>,                          <span class="co"># recovery rate for fast recoverers</span>
                                     <span class="dt">rho =</span> <span class="fl">0.95</span>,                               <span class="co"># binomial sampling probability</span>
                                     <span class="dt">S0 =</span> <span class="fl">0.94</span>,
                                     <span class="dt">E0 =</span> <span class="fl">0.05</span>,
                                     <span class="dt">I0 =</span> <span class="fl">0.01</span>,
                                     <span class="dt">R0 =</span> <span class="dv">0</span>),      <span class="co"># initial state probabilities</span>
                          <span class="dt">rates =</span> <span class="kw">c</span>(<span class="st">&quot;beta*I&quot;</span>, <span class="st">&quot;gamma&quot;</span>, <span class="st">&quot;mu&quot;</span>), <span class="co"># unlumped transition rates</span>
                          <span class="dt">flow =</span> <span class="kw">matrix</span>(<span class="kw">c</span>(-<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>,  <span class="co"># S -&gt; E</span>
                                          <span class="dv">0</span>, -<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>,  <span class="co"># E -&gt; In</span>
                                          <span class="dv">0</span>, <span class="dv">0</span>, -<span class="dv">1</span>, <span class="dv">1</span>), <span class="co"># I -&gt; R</span>
                                        <span class="dt">ncol =</span> <span class="dv">4</span>, <span class="dt">byrow =</span> T),
                          
                          <span class="dt">meas_vars =</span> <span class="kw">c</span>(<span class="st">&quot;I&quot;</span>),
                          <span class="dt">r_meas_process =</span> r_meas_process)

<span class="co"># simulate the epidemic and the dataset.</span>
epimodel &lt;-
<span class="st">          </span><span class="kw">simulate_epimodel</span>(
                    <span class="dt">epimodel =</span> epimodel,
                    <span class="dt">init_state =</span> <span class="kw">c</span>(
                              <span class="dt">S =</span> <span class="dv">397</span>,
                              <span class="dt">E =</span> <span class="dv">2</span>,
                              <span class="dt">I =</span> <span class="dv">1</span>,
                              <span class="dt">R =</span> <span class="dv">0</span>
                    ),
                    <span class="dt">trim =</span> <span class="ot">TRUE</span>
          )

dat1 &lt;-<span class="st"> </span><span class="kw">cbind</span>(<span class="dt">time =</span> epimodel$dat[,<span class="st">&quot;time&quot;</span>], <span class="dt">I =</span> epimodel$dat[,<span class="st">&quot;I&quot;</span>])
true_path1 &lt;-<span class="st"> </span>epimodel$pop_mat

epimodel &lt;-<span class="st"> </span><span class="kw">init_epimodel</span>(<span class="dt">obstimes =</span> <span class="kw">seq</span>(<span class="dv">183</span>, <span class="dv">729</span>, <span class="dt">by =</span> <span class="dv">7</span>),                    <span class="co"># vector of observation times</span>
                          <span class="dt">popsize =</span> <span class="dv">400</span>,                                      <span class="co"># population size</span>
                          <span class="dt">states =</span> <span class="kw">c</span>(<span class="st">&quot;S&quot;</span>, <span class="st">&quot;E&quot;</span>, <span class="st">&quot;I&quot;</span>, <span class="st">&quot;R&quot;</span>),                <span class="co"># compartment names</span>
                          <span class="dt">params =</span> <span class="kw">c</span>(<span class="dt">beta =</span> <span class="fl">0.0001</span>,                     <span class="co"># per-contact infectivity parameter high</span>
                                     <span class="dt">gamma =</span> <span class="dv">1</span>/<span class="dv">210</span>,                      <span class="co"># exposed compartment</span>
                                     <span class="dt">mu =</span> <span class="dv">1</span>/<span class="dv">330</span>,                          <span class="co"># recovery rate for fast recoverers</span>
                                     <span class="dt">rho =</span> <span class="fl">0.95</span>,                               <span class="co"># binomial sampling probability</span>
                                     <span class="dt">S0 =</span> <span class="fl">0.94</span>,
                                     <span class="dt">E0 =</span> <span class="fl">0.05</span>,
                                     <span class="dt">I0 =</span> <span class="fl">0.01</span>,
                                     <span class="dt">R0 =</span> <span class="dv">0</span>),      <span class="co"># initial state probabilities</span>
                          <span class="dt">rates =</span> <span class="kw">c</span>(<span class="st">&quot;beta*I&quot;</span>, <span class="st">&quot;gamma&quot;</span>, <span class="st">&quot;mu&quot;</span>), <span class="co"># unlumped transition rates</span>
                          <span class="dt">flow =</span> <span class="kw">matrix</span>(<span class="kw">c</span>(-<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>,  <span class="co"># S -&gt; E</span>
                                          <span class="dv">0</span>, -<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>,  <span class="co"># E -&gt; In</span>
                                          <span class="dv">0</span>, <span class="dv">0</span>, -<span class="dv">1</span>, <span class="dv">1</span>), <span class="co"># I -&gt; R</span>
                                        <span class="dt">ncol =</span> <span class="dv">4</span>, <span class="dt">byrow =</span> T),
                          
                          <span class="dt">meas_vars =</span> <span class="kw">c</span>(<span class="st">&quot;I&quot;</span>),
                          <span class="dt">r_meas_process =</span> r_meas_process)

<span class="co"># simulate the epidemic and the dataset.</span>
epimodel &lt;-
<span class="st">          </span><span class="kw">simulate_epimodel</span>(
                    <span class="dt">epimodel =</span> epimodel,
                    <span class="dt">init_state =</span> <span class="kw">c</span>(true_path1[<span class="kw">nrow</span>(true_path1),<span class="st">&quot;S&quot;</span>],
                                   true_path1[<span class="kw">nrow</span>(true_path1),<span class="st">&quot;E&quot;</span>],
                                   true_path1[<span class="kw">nrow</span>(true_path1),<span class="st">&quot;I&quot;</span>],
                                   true_path1[<span class="kw">nrow</span>(true_path1),<span class="st">&quot;R&quot;</span>]
                    ),
                    <span class="dt">trim =</span> <span class="ot">TRUE</span>
          )

dat2 &lt;-<span class="st"> </span><span class="kw">cbind</span>(<span class="dt">time =</span> epimodel$dat[,<span class="st">&quot;time&quot;</span>], <span class="dt">I =</span> epimodel$dat[,<span class="st">&quot;I&quot;</span>])
true_path2 &lt;-<span class="st"> </span>epimodel$pop_mat

<span class="co"># initialize the stochastic epidemic model object</span>
epimodel &lt;-<span class="st"> </span><span class="kw">init_epimodel</span>(<span class="dt">obstimes =</span> <span class="kw">seq</span>(<span class="dv">729</span>, <span class="dv">1163</span>, <span class="dt">by =</span> <span class="dv">7</span>),                    <span class="co"># vector of observation times</span>
                          <span class="dt">popsize =</span> <span class="dv">400</span>,                                      <span class="co"># population size</span>
                          <span class="dt">states =</span> <span class="kw">c</span>(<span class="st">&quot;S&quot;</span>, <span class="st">&quot;E&quot;</span>, <span class="st">&quot;I&quot;</span>, <span class="st">&quot;R&quot;</span>), <span class="co"># compartment names</span>
                          <span class="dt">params =</span> <span class="kw">c</span>(<span class="dt">beta =</span> <span class="fl">0.00035</span>,                     <span class="co"># per-contact infectivity parameter high</span>
                                     <span class="dt">gamma =</span> <span class="dv">1</span>/<span class="dv">90</span>,                      <span class="co"># exposed compartment</span>
                                     <span class="dt">mu =</span> <span class="dv">1</span>/<span class="dv">300</span>,                          <span class="co"># recovery rate for fast recoverers</span>
                                     <span class="dt">rho =</span> <span class="fl">0.95</span>,                               <span class="co"># binomial sampling probability</span>
                                     <span class="dt">S0 =</span> <span class="fl">0.94</span>,
                                     <span class="dt">E0 =</span> <span class="fl">0.05</span>,
                                     <span class="dt">I0 =</span> <span class="fl">0.01</span>,
                                     <span class="dt">R0 =</span> <span class="dv">0</span>),      <span class="co"># initial state probabilities</span>
                          <span class="dt">rates =</span> <span class="kw">c</span>(<span class="st">&quot;beta*I&quot;</span>, <span class="st">&quot;gamma&quot;</span>, <span class="st">&quot;mu&quot;</span>), <span class="co"># unlumped transition rates</span>
                          <span class="dt">flow =</span> <span class="kw">matrix</span>(<span class="kw">c</span>(-<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>,  <span class="co"># S -&gt; E</span>
                                          <span class="dv">0</span>, -<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>,  <span class="co"># E -&gt; In</span>
                                          <span class="dv">0</span>, <span class="dv">0</span>, -<span class="dv">1</span>, <span class="dv">1</span>), <span class="co"># I -&gt; R</span>
                                        <span class="dt">ncol =</span> <span class="dv">4</span>, <span class="dt">byrow =</span> T),
                          
                          <span class="dt">meas_vars =</span> <span class="kw">c</span>(<span class="st">&quot;I&quot;</span>),
                          <span class="dt">r_meas_process =</span> r_meas_process)


<span class="co"># simulate the epidemic and the dataset.</span>
epimodel &lt;-
<span class="st">          </span><span class="kw">simulate_epimodel</span>(
                    <span class="dt">epimodel =</span> epimodel,
                    <span class="dt">init_state =</span> <span class="kw">c</span>(true_path2[<span class="kw">nrow</span>(true_path2),<span class="st">&quot;S&quot;</span>],
                                   true_path2[<span class="kw">nrow</span>(true_path2),<span class="st">&quot;E&quot;</span>],
                                   true_path2[<span class="kw">nrow</span>(true_path2),<span class="st">&quot;I&quot;</span>],
                                   true_path2[<span class="kw">nrow</span>(true_path2),<span class="st">&quot;R&quot;</span>]
                    ),
                    <span class="dt">trim =</span> <span class="ot">TRUE</span>
          )

dat3 &lt;-<span class="st"> </span><span class="kw">cbind</span>(<span class="dt">time =</span> epimodel$dat[,<span class="st">&quot;time&quot;</span>], <span class="dt">I =</span> epimodel$dat[,<span class="st">&quot;I&quot;</span>])
true_path3 &lt;-<span class="st"> </span>epimodel$pop_mat

<span class="co"># initialize the stochastic epidemic model object</span>
epimodel &lt;-<span class="st"> </span><span class="kw">init_epimodel</span>(<span class="dt">obstimes =</span> <span class="kw">seq</span>(<span class="dv">1163</span>, <span class="dv">1457</span>, <span class="dt">by =</span> <span class="dv">7</span>),                    <span class="co"># vector of observation times</span>
                          <span class="dt">popsize =</span> <span class="dv">400</span>,                                      <span class="co"># population size</span>
                          <span class="dt">states =</span> <span class="kw">c</span>(<span class="st">&quot;S&quot;</span>, <span class="st">&quot;E&quot;</span>, <span class="st">&quot;I&quot;</span>, <span class="st">&quot;R&quot;</span>), <span class="co"># compartment names</span>
                          <span class="dt">params =</span> <span class="kw">c</span>(<span class="dt">beta =</span> <span class="fl">0.0001</span>,                     <span class="co"># per-contact infectivity parameter high</span>
                                     <span class="dt">gamma =</span> <span class="dv">1</span>/<span class="dv">180</span>,                      <span class="co"># exposed compartment</span>
                                     <span class="dt">mu =</span> <span class="dv">1</span>/<span class="dv">70</span>,                          <span class="co"># recovery rate for fast recoverers</span>
                                     <span class="dt">rho =</span> <span class="fl">0.95</span>,                               <span class="co"># binomial sampling probability</span>
                                     <span class="dt">S0 =</span> <span class="fl">0.94</span>,
                                     <span class="dt">E0 =</span> <span class="fl">0.05</span>,
                                     <span class="dt">I0 =</span> <span class="fl">0.01</span>,
                                     <span class="dt">R0 =</span> <span class="dv">0</span>),      <span class="co"># initial state probabilities</span>
                          <span class="dt">rates =</span> <span class="kw">c</span>(<span class="st">&quot;beta*I&quot;</span>, <span class="st">&quot;gamma&quot;</span>, <span class="st">&quot;mu&quot;</span>), <span class="co"># unlumped transition rates</span>
                          <span class="dt">flow =</span> <span class="kw">matrix</span>(<span class="kw">c</span>(-<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>,  <span class="co"># S -&gt; E</span>
                                          <span class="dv">0</span>, -<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>,  <span class="co"># E -&gt; In</span>
                                          <span class="dv">0</span>, <span class="dv">0</span>, -<span class="dv">1</span>, <span class="dv">1</span>), <span class="co"># I -&gt; R</span>
                                        <span class="dt">ncol =</span> <span class="dv">4</span>, <span class="dt">byrow =</span> T),
                          
                          <span class="dt">meas_vars =</span> <span class="kw">c</span>(<span class="st">&quot;I&quot;</span>),
                          <span class="dt">r_meas_process =</span> r_meas_process)


<span class="co"># simulate the epidemic and the dataset.</span>
epimodel &lt;-
<span class="st">          </span><span class="kw">simulate_epimodel</span>(
                    <span class="dt">epimodel =</span> epimodel,
                    <span class="dt">init_state =</span> <span class="kw">c</span>(true_path3[<span class="kw">nrow</span>(true_path3),<span class="st">&quot;S&quot;</span>],
                                   true_path3[<span class="kw">nrow</span>(true_path3),<span class="st">&quot;E&quot;</span>],
                                   true_path3[<span class="kw">nrow</span>(true_path3),<span class="st">&quot;I&quot;</span>],
                                   true_path3[<span class="kw">nrow</span>(true_path3),<span class="st">&quot;R&quot;</span>]
                    ),
                    <span class="dt">trim =</span> <span class="ot">TRUE</span>
          )

dat4 &lt;-<span class="st"> </span><span class="kw">cbind</span>(<span class="dt">time =</span> epimodel$dat[,<span class="st">&quot;time&quot;</span>], <span class="dt">I =</span> epimodel$dat[,<span class="st">&quot;I&quot;</span>])
true_path4 &lt;-<span class="st"> </span>epimodel$pop_mat

dat &lt;-<span class="st"> </span><span class="kw">rbind</span>(dat1, dat2[-<span class="kw">c</span>(<span class="dv">1</span>),], dat3[-<span class="dv">1</span>,], dat4[-<span class="dv">1</span>,])
true_path &lt;-<span class="st"> </span><span class="kw">rbind</span>(true_path1[-<span class="kw">nrow</span>(true_path1),<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">4</span>:<span class="dv">7</span>)], 
                   true_path2[-<span class="kw">c</span>(<span class="dv">1</span>, <span class="kw">nrow</span>(true_path2)), <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">4</span>:<span class="dv">7</span>)],
                   true_path3[-<span class="kw">c</span>(<span class="dv">1</span>, <span class="kw">nrow</span>(true_path3)), <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">4</span>:<span class="dv">7</span>)],
                   true_path4[-<span class="dv">1</span>, <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">4</span>:<span class="dv">7</span>)])

<span class="kw">plot</span>(true_path[,<span class="dv">1</span>], true_path[,<span class="kw">c</span>(<span class="st">&quot;I&quot;</span>)], <span class="st">&quot;l&quot;</span>); <span class="kw">points</span>(dat)
<span class="kw">abline</span>(<span class="dt">v =</span> <span class="kw">c</span>(<span class="dv">183</span>, <span class="dv">729</span>, <span class="dv">1163</span>), <span class="dt">col =</span> <span class="st">&quot;red&quot;</span>)</code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
<p>Having simulated a dataset, we can now proceed to fit SIR and SEIR models to the data. In fitting each model, the first step is to define a transition kernel for the model parameters. The parameters are updated from their univariate full conditional distributions via Gibbs sampling (prior distributions indicated in comments in the code below). The following code implements the transition kernel and a helper function for computing the sufficient statistics:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># helper function for computing the sufficient statistics for the SIR model rate parameters</span>
Rcpp::<span class="kw">cppFunction</span>(<span class="st">&quot;Rcpp::NumericVector getSuffStats_SIR(const Rcpp::NumericMatrix&amp; pop_mat, const int ind_final_config) {</span>
<span class="st">                  </span>
<span class="st">          // initialize sufficient statistics</span>
<span class="st">          int num_inf = 0;       // number of infection events</span>
<span class="st">          int num_rec = 0;       // number of recovery events</span>
<span class="st">          double beta_suff = 0;  // integrated hazard for the infectivity</span>
<span class="st">          double mu_suff = 0;    // integrated hazard for the recovery</span>

<span class="st">          // initialize times</span>
<span class="st">          double cur_time = 0;              // current time</span>
<span class="st">          double next_time = pop_mat(0,0);  // time of the first event</span>
<span class="st">          double dt = 0;                    // time increment</span>
<span class="st">          </span>
<span class="st">          // compute the sufficient statistics - loop through the pop_mat matrix until</span>
<span class="st">          // reaching the row for the final observation time</span>
<span class="st">          for(int j = 0; j &lt; ind_final_config - 1; ++j) {</span>
<span class="st">          </span>
<span class="st">                    cur_time = next_time;         </span>
<span class="st">                    next_time = pop_mat(j+1, 0); // grab the time of the next event</span>
<span class="st">                    dt = next_time - cur_time;   // compute the time increment</span>
<span class="st">                    </span>
<span class="st">                    beta_suff += pop_mat(j, 3) * pop_mat(j, 4) * dt; // add S*I*(t_{j+1} - t_j) to beta_suff</span>
<span class="st">                    mu_suff += pop_mat(j, 4) * dt;                   // add I*(t_{j+1} - t_j) to mu_suff</span>
<span class="st">                    </span>
<span class="st">                    // increment the count for the next event</span>
<span class="st">                    if(pop_mat(j + 1, 2) == 1) {  </span>
<span class="st">                              num_inf += 1;</span>
<span class="st">                    } else if(pop_mat(j + 1, 2) == 2) {</span>
<span class="st">                              num_rec += 1;</span>
<span class="st">                    }</span>
<span class="st">          }</span>
<span class="st">                  </span>
<span class="st">          // return the vector of sufficient statistics for the rate parameters</span>
<span class="st">          return Rcpp::NumericVector::create(num_inf, beta_suff, num_rec, mu_suff);</span>
<span class="st">}&quot;</span>)

<span class="co"># MCMC transition kernel for the SEIR model rate parameters and the binomial</span>
<span class="co"># sampling probability. The prior distributions for the parameters are contained</span>
<span class="co"># in this function.</span>

gibbs_kernel_SIR &lt;-<span class="st"> </span>function(epimodel) {
          
          <span class="co"># get sufficient statistics using the previously compiled getSuffStats function (above)</span>
          suff_stats          &lt;-<span class="st"> </span><span class="kw">getSuffStats_SIR</span>(epimodel$pop_mat, epimodel$ind_final_config)
          
          ### update parameters from their univariate full conditional distributions
          ## beta ~ Gamma(0.6, 10000)
          ## mu   ~ Gamma(0.7, 100)
          ## rho  ~ Beta(10, 1)
          proposal          &lt;-<span class="st"> </span>epimodel$params <span class="co"># params is the vector of ALL model parameters</span>
          proposal[<span class="st">&quot;beta&quot;</span>]  &lt;-<span class="st"> </span><span class="kw">rgamma</span>(<span class="dv">1</span>, <span class="fl">0.6</span> +<span class="st"> </span>suff_stats[<span class="dv">1</span>], <span class="dv">10000</span> +<span class="st"> </span>suff_stats[<span class="dv">2</span>])
          proposal[<span class="st">&quot;mu&quot;</span>]    &lt;-<span class="st"> </span><span class="kw">rgamma</span>(<span class="dv">1</span>, <span class="fl">0.7</span> +<span class="st"> </span>suff_stats[<span class="dv">3</span>], <span class="dv">100</span> +<span class="st"> </span>suff_stats[<span class="dv">4</span>])
          proposal[<span class="st">&quot;rho&quot;</span>]   &lt;-<span class="st"> </span><span class="kw">rbeta</span>(<span class="dv">1</span>, 
                                     <span class="dt">shape1 =</span> <span class="dv">10</span> +<span class="st"> </span><span class="kw">sum</span>(epimodel$obs_mat[, <span class="st">&quot;I_observed&quot;</span>]),
                                     <span class="dt">shape2 =</span> <span class="dv">1</span> +<span class="st"> </span><span class="kw">sum</span>(epimodel$obs_mat[, <span class="st">&quot;I_augmented&quot;</span>] -<span class="st"> </span>epimodel$obs_mat[, <span class="st">&quot;I_observed&quot;</span>]))
          
          <span class="co"># update array of rate matrices</span>
          epimodel          &lt;-<span class="st"> </span><span class="kw">build_new_irms</span>(epimodel, proposal)
          
          <span class="co"># update the eigen decompositions (This function is built in)</span>
          <span class="kw">buildEigenArray_SIR</span>(<span class="dt">real_eigenvals =</span> epimodel$real_eigen_values,
                              <span class="dt">imag_eigenvals =</span> epimodel$imag_eigen_values,
                              <span class="dt">eigenvecs      =</span> epimodel$eigen_vectors, 
                              <span class="dt">inversevecs    =</span> epimodel$inv_eigen_vectors, 
                              <span class="dt">irm_array      =</span> epimodel$irm, 
                              <span class="dt">n_real_eigs    =</span> epimodel$n_real_eigs, 
                              <span class="dt">initial_calc   =</span> <span class="ot">FALSE</span>)
          
          <span class="co"># get log-likelihood of the observations under the new parameters</span>
          obs_likelihood_new  &lt;-<span class="st"> </span><span class="kw">calc_obs_likelihood</span>(epimodel, <span class="dt">params =</span> proposal, <span class="dt">log =</span> <span class="ot">TRUE</span>) #### NOTE - log = TRUE
          
          <span class="co"># get the new population level CTMC log-likelihood</span>
          pop_likelihood_new  &lt;-<span class="st"> </span>epimodel$likelihoods$pop_likelihood_cur +
<span class="st">                    </span>suff_stats[<span class="dv">1</span>] *<span class="st"> </span>(<span class="kw">log</span>(proposal[<span class="st">&quot;beta&quot;</span>]) -<span class="st"> </span><span class="kw">log</span>(epimodel$params[<span class="st">&quot;beta&quot;</span>])) +
<span class="st">                    </span>suff_stats[<span class="dv">3</span>] *<span class="st"> </span>(<span class="kw">log</span>(proposal[<span class="st">&quot;mu&quot;</span>]) -<span class="st"> </span><span class="kw">log</span>(epimodel$params[<span class="st">&quot;mu&quot;</span>])) -
<span class="st">                    </span>suff_stats[<span class="dv">2</span>] *<span class="st"> </span>(proposal[<span class="st">&quot;beta&quot;</span>] -<span class="st"> </span>epimodel$params[<span class="st">&quot;beta&quot;</span>]) -<span class="st"> </span>
<span class="st">                    </span>suff_stats[<span class="dv">4</span>] *<span class="st"> </span>(proposal[<span class="st">&quot;mu&quot;</span>] -<span class="st"> </span>epimodel$params[<span class="st">&quot;mu&quot;</span>])
          
          <span class="co"># update parameters, likelihood objects, and eigen decompositions</span>
          epimodel  &lt;-
<span class="st">                    </span><span class="kw">update_params</span>(
                              epimodel,
                              <span class="dt">params =</span> proposal,
                              <span class="dt">pop_likelihood =</span> pop_likelihood_new,
                              <span class="dt">obs_likelihood =</span> obs_likelihood_new
                    )
          
          <span class="kw">return</span>(epimodel)
}

### Helper function for computing the SEIR model sufficient statistics
Rcpp::<span class="kw">cppFunction</span>(<span class="st">&quot;Rcpp::NumericVector getSuffStats_SEIR(const Rcpp::NumericMatrix&amp; pop_mat, const int ind_final_config) {</span>
<span class="st">                  </span>
<span class="st">          // initialize sufficient statistics</span>
<span class="st">          int num_exp = 0;       // number of exposure events</span>
<span class="st">          int num_inf = 0;       // number of exposed --&gt; infectious events</span>
<span class="st">          int num_rec = 0;       // number of recovery events</span>
<span class="st">          double beta_suff  = 0; // integrated hazard for the exposure</span>
<span class="st">          double gamma_suff = 0; // integrated hazard for addition of infectives</span>
<span class="st">          double mu_suff    = 0; // integrated hazard for the recovery</span>
<span class="st">          </span>
<span class="st">          // initialize times</span>
<span class="st">          double cur_time = 0;              // current time</span>
<span class="st">          double next_time = pop_mat(0,0);  // time of the first event</span>
<span class="st">          double dt = 0;                    // time increment</span>

<span class="st">          // compute the sufficient statistics - loop through the pop_mat matrix until</span>
<span class="st">          // reaching the row for the final observation time</span>
<span class="st">          for(int j = 0; j &lt; ind_final_config - 1; ++j) {</span>

<span class="st">                    cur_time = next_time;         </span>
<span class="st">                    next_time = pop_mat(j+1, 0); // grab the time of the next event</span>
<span class="st">                    dt = next_time - cur_time;</span>

<span class="st">                    beta_suff  += pop_mat(j, 3) * pop_mat(j, 5) * dt; // add S*I*(t_{j+1} - t_j) to beta_suff</span>
<span class="st">                    gamma_suff += pop_mat(j, 4) * dt;                 // add E*(t_{j+1} - t_j) to gamma_suff</span>
<span class="st">                    mu_suff    += pop_mat(j, 5) * dt;                 // add I*(t_{j+1} - t_j) to mu_suff</span>
<span class="st">                    </span>
<span class="st">                    if(pop_mat(j + 1, 2) == 1) {  </span>
<span class="st">                              num_exp += 1;            // if the next event is an exposure, increment the number of exposures</span>
<span class="st">                    } else if(pop_mat(j + 1, 2) == 2) {</span>
<span class="st">                              num_inf += 1;            // if the next event adds an infective, increment the number of infections</span>
<span class="st">                    } else if(pop_mat(j + 1, 2) == 3) {</span>
<span class="st">                              num_rec += 1;            // if the next event is a recover, increment the number of recovery</span>
<span class="st">                    }</span>
<span class="st">          }</span>
<span class="st">          </span>
<span class="st">          // return the vector of sufficient statistics for the rate parameters</span>
<span class="st">          return Rcpp::NumericVector::create(num_exp, beta_suff, num_inf, gamma_suff, num_rec, mu_suff);</span>
<span class="st">}&quot;</span>)

<span class="co"># MCMC transition kernel for the SEIR model rate parameters and the binomial</span>
<span class="co"># sampling probability. The prior distributions for the parameters are contained</span>
<span class="co"># in this function.</span>
gibbs_kernel_SEIR &lt;-<span class="st"> </span>function(epimodel) {
          
          <span class="co"># get sufficient statistics using the previously compiled getSuffStats function (above)</span>
          suff_stats          &lt;-<span class="st"> </span><span class="kw">getSuffStats_SEIR</span>(epimodel$pop_mat, epimodel$ind_final_config)
          
          ### update parameters from their univariate full conditional distributions
          ## beta  ~ Gamma(0.6, 10000)
          ## gamma ~ Gamma(0.5,50)
          ## mu    ~ Gamma(0.7, 100)
          ## rho   ~ Beta(10, 1)          
          proposal          &lt;-<span class="st"> </span>epimodel$params <span class="co"># params is the vector of ALL model parameters</span>
          proposal[<span class="st">&quot;beta&quot;</span>]  &lt;-<span class="st"> </span><span class="kw">rgamma</span>(<span class="dv">1</span>, <span class="fl">0.6</span> +<span class="st"> </span>suff_stats[<span class="dv">1</span>], <span class="dv">10000</span> +<span class="st"> </span>suff_stats[<span class="dv">2</span>])
          proposal[<span class="st">&quot;gamma&quot;</span>] &lt;-<span class="st"> </span><span class="kw">rgamma</span>(<span class="dv">1</span>, <span class="fl">0.5</span> +<span class="st"> </span>suff_stats[<span class="dv">3</span>], <span class="dv">50</span> +<span class="st"> </span>suff_stats[<span class="dv">4</span>])
          proposal[<span class="st">&quot;mu&quot;</span>]    &lt;-<span class="st"> </span><span class="kw">rgamma</span>(<span class="dv">1</span>, <span class="fl">0.7</span> +<span class="st"> </span>suff_stats[<span class="dv">5</span>], <span class="dv">100</span> +<span class="st"> </span>suff_stats[<span class="dv">6</span>])
          proposal[<span class="st">&quot;rho&quot;</span>]   &lt;-<span class="st"> </span><span class="kw">rbeta</span>(<span class="dv">1</span>, 
                                     <span class="dt">shape1 =</span> <span class="dv">10</span> +<span class="st"> </span><span class="kw">sum</span>(epimodel$obs_mat[,<span class="st">&quot;I_observed&quot;</span>]), 
                                     <span class="dt">shape2 =</span> <span class="dv">1</span> +<span class="st"> </span><span class="kw">sum</span>(epimodel$obs_mat[,<span class="st">&quot;I_augmented&quot;</span>]-<span class="st"> </span>epimodel$obs_mat[,<span class="st">&quot;I_observed&quot;</span>]))
          
          <span class="co"># update array of rate matrices</span>
          epimodel          &lt;-<span class="st"> </span><span class="kw">build_new_irms</span>(epimodel, proposal)
          
          <span class="co"># update the eigen decompositions</span>
          <span class="kw">buildEigenArray_SEIR</span>(<span class="dt">real_eigenvals =</span> epimodel$real_eigen_values,
                               <span class="dt">imag_eigenvals =</span> epimodel$imag_eigen_values,
                               <span class="dt">eigenvecs      =</span> epimodel$eigen_vectors, 
                               <span class="dt">inversevecs    =</span> epimodel$inv_eigen_vectors, 
                               <span class="dt">irm_array      =</span> epimodel$irm, 
                               <span class="dt">n_real_eigs    =</span> epimodel$n_real_eigs, 
                               <span class="dt">initial_calc   =</span> <span class="ot">FALSE</span>)
          
          <span class="co"># get log-likelihoods under the new parameters</span>
          pop_likelihood_new  &lt;-<span class="st"> </span><span class="kw">calc_pop_likelihood</span>(epimodel, <span class="dt">log =</span> <span class="ot">TRUE</span>) #### NOTE - log = TRUE
          obs_likelihood_new  &lt;-<span class="st"> </span><span class="kw">calc_obs_likelihood</span>(epimodel, <span class="dt">params =</span> proposal, <span class="dt">log =</span> <span class="ot">TRUE</span>) #### NOTE - log = TRUE
          
          <span class="co"># update parameters, likelihood objects, and eigen decompositions</span>
          epimodel            &lt;-<span class="st"> </span><span class="kw">update_params</span>(epimodel, <span class="dt">params =</span> proposal, <span class="dt">pop_likelihood =</span> pop_likelihood_new, <span class="dt">obs_likelihood =</span> obs_likelihood_new)
          
          <span class="kw">return</span>(epimodel)
}</code></pre></div>
<p>We now re-initialize an epimodel objects with the dataset, set the RNG seed, and run each MCMC chain as follows. Note that the chain was set by a batch script that varied the value of <code>chain</code> (chain = 1,2,3).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">chain &lt;-<span class="st"> </span><span class="dv">1</span> <span class="co"># this was set by a batch script that ran chains 1, 2, and 3 in parallel</span>

<span class="co"># generate the measurement process</span>
d_meas_process &lt;-<span class="st"> </span>function(state, meas_vars, params, <span class="dt">log =</span> <span class="ot">TRUE</span>) {
        <span class="co"># note that the names of the measurement variables are endowed with suffixes &quot;_observed&quot; and &quot;_augmented&quot;. This is required.</span>
        <span class="co"># we will declare the names of the measurement variables shortly.</span>
        <span class="kw">dbinom</span>(<span class="dt">x =</span> state[, <span class="st">&quot;I_observed&quot;</span>],
               <span class="dt">size =</span> state[, <span class="st">&quot;I_augmented&quot;</span>],
               <span class="dt">prob =</span> params[<span class="st">&quot;rho&quot;</span>], <span class="dt">log =</span> log)
}

<span class="co"># re-initialize the chain</span>
init_dist_SIR &lt;-<span class="st"> </span><span class="kw">normalize</span>(<span class="kw">c</span>(<span class="fl">0.99</span>, <span class="fl">0.004</span>, <span class="fl">0.0001</span>))
epimodel_SIR  &lt;-<span class="st"> </span><span class="kw">init_epimodel</span>(<span class="dt">popsize =</span> <span class="dv">400</span>,                                                    <span class="co"># population size</span>
                           <span class="dt">states =</span> <span class="kw">c</span>(<span class="st">&quot;S&quot;</span>, <span class="st">&quot;I&quot;</span>, <span class="st">&quot;R&quot;</span>),                                         <span class="co"># compartment names</span>
                           <span class="dt">params =</span> <span class="kw">c</span>(<span class="dt">beta =</span> <span class="kw">abs</span>(<span class="kw">rnorm</span>(<span class="dv">1</span>, <span class="fl">0.00005</span>, <span class="fl">1e-5</span>)),                   <span class="co"># infectivity rate</span>
                                      <span class="dt">mu =</span> <span class="kw">abs</span>(<span class="kw">rnorm</span>(<span class="dv">1</span>, <span class="fl">0.002</span>, <span class="fl">0.0001</span>)),                      <span class="co"># recovery rate</span>
                                      <span class="dt">rho =</span> <span class="kw">rbeta</span>(<span class="dv">1</span>, <span class="dv">10</span>, <span class="dv">1</span>),                                 <span class="co"># binomial sampling prob</span>
                                      <span class="dt">S0 =</span> init_dist_SIR[<span class="dv">1</span>], <span class="dt">I0 =</span> init_dist_SIR[<span class="dv">2</span>], <span class="dt">R0 =</span> init_dist_SIR[<span class="dv">3</span>]),
                           <span class="dt">rates =</span> <span class="kw">c</span>(<span class="st">&quot;beta * I&quot;</span>, <span class="st">&quot;mu&quot;</span>),                <span class="co"># unlumped transition rates</span>
                           <span class="dt">flow =</span> <span class="kw">matrix</span>(<span class="kw">c</span>(-<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>,
                                           <span class="dv">0</span>, -<span class="dv">1</span>, <span class="dv">1</span>), <span class="dt">ncol =</span> <span class="dv">3</span>, <span class="dt">byrow =</span> T),  <span class="co"># flow matrix</span>
                           <span class="dt">dat =</span> dat,                                           <span class="co"># dataset</span>
                           <span class="dt">time_var =</span> <span class="st">&quot;time&quot;</span>,                                   <span class="co"># name of time variable in the dataset</span>
                           <span class="dt">meas_vars =</span> <span class="st">&quot;I&quot;</span>,                                     <span class="co"># name of measurement var in the dataset</span>
                           <span class="dt">initdist_prior =</span> <span class="kw">c</span>(<span class="dv">90</span>, <span class="fl">0.5</span>, <span class="fl">0.01</span>), ### Parameters for the dirichlet prior distribution
                           <span class="dt">d_meas_process =</span> d_meas_process)

epimodel_SIR &lt;-<span class="st"> </span><span class="kw">init_settings</span>(epimodel_SIR,
                          <span class="dt">niter =</span> <span class="dv">10</span>, <span class="co"># this was set to 100000 in the paper</span>
                          <span class="dt">save_params_every =</span> <span class="dv">1</span>,
                          <span class="dt">save_configs_every =</span> <span class="dv">2</span>, <span class="co"># this was set to 250 for the chains run in the paper</span>
                          <span class="dt">kernel =</span> <span class="kw">list</span>(gibbs_kernel_SIR),
                          <span class="dt">configs_to_redraw =</span> <span class="dv">2</span>, <span class="co"># set to 150 for the paper</span>
                          <span class="dt">analytic_eigen =</span> <span class="st">&quot;SIR&quot;</span>,
                          <span class="dt">ecctmc_method =</span> <span class="st">&quot;unif&quot;</span>,
                          <span class="dt">seed =</span> <span class="dv">52787</span> +<span class="st"> </span>chain)

<span class="co"># Fit the epimodel --------------------------------------------------------</span>

epimodel_SIR &lt;-<span class="st"> </span><span class="kw">fit_epimodel</span>(epimodel_SIR, <span class="dt">monitor =</span> <span class="ot">TRUE</span>)</code></pre></div>
<pre><code>## [1] &quot;Configuration initialized. Beginning MCMC.&quot;
## [1] 2
## [1] 4
## [1] 6
## [1] 8
## [1] 10</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">chain &lt;-<span class="st"> </span><span class="dv">1</span> <span class="co"># this was set by a batch script that ran chains 1, 2, and 3 in parallel</span>

<span class="co"># generate the measurement process</span>
d_meas_process &lt;-<span class="st"> </span>function(state, meas_vars, params, <span class="dt">log =</span> <span class="ot">TRUE</span>) {
        <span class="co"># note that the names of the measurement variables are endowed with suffixes &quot;_observed&quot; and &quot;_augmented&quot;. This is required.</span>
        <span class="co"># we will declare the names of the measurement variables shortly.</span>
        <span class="kw">dbinom</span>(<span class="dt">x =</span> state[, <span class="st">&quot;I_observed&quot;</span>],
               <span class="dt">size =</span> state[, <span class="st">&quot;I_augmented&quot;</span>],
               <span class="dt">prob =</span> params[<span class="st">&quot;rho&quot;</span>], <span class="dt">log =</span> log)
}

<span class="co"># re-initialize the chain</span>
init_dist_SEIR &lt;-<span class="st"> </span><span class="kw">normalize</span>(<span class="kw">c</span>(<span class="dv">90</span>, <span class="fl">0.5</span>, <span class="fl">0.5</span>, <span class="fl">0.01</span>))
epimodel_SEIR  &lt;-<span class="st"> </span><span class="kw">init_epimodel</span>(<span class="dt">popsize =</span> <span class="dv">400</span>,                                                    <span class="co"># population size</span>
                           <span class="dt">states =</span> <span class="kw">c</span>(<span class="st">&quot;S&quot;</span>, <span class="st">&quot;E&quot;</span>, <span class="st">&quot;I&quot;</span>, <span class="st">&quot;R&quot;</span>),                                         <span class="co"># compartment names</span>
                           <span class="dt">params =</span> <span class="kw">c</span>(<span class="dt">beta =</span> <span class="kw">abs</span>(<span class="kw">rnorm</span>(<span class="dv">1</span>, <span class="fl">0.00008</span>, <span class="fl">1e-6</span>)),                      <span class="co"># infectivity rate</span>
                                      <span class="dt">gamma =</span> <span class="kw">abs</span>(<span class="kw">rnorm</span>(<span class="dv">1</span>, <span class="fl">0.008</span>, <span class="fl">1e-3</span>)),
                                      <span class="dt">mu =</span> <span class="kw">abs</span>(<span class="kw">rnorm</span>(<span class="dv">1</span>, <span class="fl">0.0012</span>, <span class="fl">0.001</span>)),                          <span class="co"># recovery rate</span>
                                      <span class="dt">rho =</span> <span class="kw">rbeta</span>(<span class="dv">1</span>, <span class="dv">10</span>, <span class="dv">1</span>),                                 <span class="co"># binomial sampling prob</span>
                                      <span class="dt">S0 =</span> init_dist_SEIR[<span class="dv">1</span>], <span class="dt">E0 =</span> init_dist_SEIR[<span class="dv">2</span>], <span class="dt">I0 =</span> init_dist_SEIR[<span class="dv">3</span>], <span class="dt">R0 =</span> init_dist_SEIR[<span class="dv">4</span>]),
                           <span class="dt">rates =</span> <span class="kw">c</span>(<span class="st">&quot;beta * I&quot;</span>, <span class="st">&quot;gamma&quot;</span>, <span class="st">&quot;mu&quot;</span>),                <span class="co"># unlumped transition rates</span>
                           <span class="dt">flow =</span> <span class="kw">matrix</span>(<span class="kw">c</span>(-<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="co"># S -&gt; E</span>
                                           <span class="dv">0</span>, -<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="co"># E -&gt; I</span>
                                           <span class="dv">0</span>, <span class="dv">0</span>, -<span class="dv">1</span>, <span class="dv">1</span>),<span class="co"># I -&gt; R</span>
                                         <span class="dt">ncol =</span> <span class="dv">4</span>, <span class="dt">byrow =</span> T),  <span class="co"># flow matrix</span>
                           <span class="dt">dat =</span> dat,                                           <span class="co"># dataset</span>
                           <span class="dt">time_var =</span> <span class="st">&quot;time&quot;</span>,                                   <span class="co"># name of time variable in the dataset</span>
                           <span class="dt">meas_vars =</span> <span class="st">&quot;I&quot;</span>,                                     <span class="co"># name of measurement var in the dataset</span>
                           <span class="dt">initdist_prior =</span> <span class="kw">c</span>(<span class="dv">90</span>, <span class="fl">0.5</span>, <span class="fl">0.5</span>, <span class="fl">0.01</span>), ### Parameters for the dirichlet prior distribution
                           <span class="dt">d_meas_process =</span> d_meas_process,
                           <span class="dt">r_meas_process =</span> r_meas_process)

epimodel_SEIR &lt;-<span class="st"> </span><span class="kw">init_settings</span>(epimodel_SEIR,
                          <span class="dt">niter =</span> <span class="dv">10</span>, <span class="co"># this was set to 100000 in the paper</span>
                          <span class="dt">save_params_every =</span> <span class="dv">1</span>,
                          <span class="dt">save_configs_every =</span> <span class="dv">2</span>, <span class="co"># this was set to 250 for the chains run in the paper</span>
                          <span class="dt">kernel =</span> <span class="kw">list</span>(gibbs_kernel_SEIR),
                          <span class="dt">configs_to_redraw =</span> <span class="dv">2</span>, <span class="co"># set to 150 for the paper</span>
                          <span class="dt">analytic_eigen =</span> <span class="st">&quot;SEIR&quot;</span>,
                          <span class="dt">ecctmc_method =</span> <span class="st">&quot;unif&quot;</span>,
                          <span class="dt">seed =</span> <span class="dv">52787</span> +<span class="st"> </span>chain)

<span class="co"># Fit the epimodel --------------------------------------------------------</span>

epimodel_SEIR &lt;-<span class="st"> </span><span class="kw">fit_epimodel</span>(epimodel_SEIR, <span class="dt">monitor =</span> <span class="ot">TRUE</span>)</code></pre></div>
<pre><code>## [1] &quot;Configuration initialized. Beginning MCMC.&quot;
## [1] 2
## [1] 4
## [1] 6
## [1] 8
## [1] 10</code></pre>
<p>After running all three chains for each model, we discarded the burn-in and combined the parameter samples and latent posterior samples from each chain. Posterior median estimates and 95% credible intervals of model parameters were computed, along with the pointwise posterior distribution of the latent process. These are presented in the paper and the supplement.</p>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
