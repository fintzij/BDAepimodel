<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Jon Fintzi, Xiang Cui, Jon Wakefield, Vladimir Minin" />

<meta name="date" content="2017-05-12" />

<title>Analyzing an epidemic with SEIR dynamics using the pomp package</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>



<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%7D%0Apre%20%7B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%20code%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>




<h1 class="title toc-ignore">Analyzing an epidemic with SEIR dynamics using the pomp package</h1>
<h4 class="author"><em>Jon Fintzi, Xiang Cui, Jon Wakefield, Vladimir Minin</em></h4>
<h4 class="date"><em>2017-05-12</em></h4>



<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(BDAepimodel)
<span class="kw">library</span>(coda)
<span class="kw">library</span>(Rcpp)
<span class="kw">library</span>(pomp)
<span class="kw">library</span>(gtools)</code></pre></div>
<pre><code>## 
## Attaching package: 'gtools'</code></pre>
<pre><code>## The following objects are masked from 'package:MCMCpack':
## 
##     ddirichlet, rdirichlet</code></pre>
<pre><code>## The following object is masked from 'package:BDAepimodel':
## 
##     logit</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(ggplot2)</code></pre></div>
<div id="analyzing-an-epidemic-with-seir-dynamics" class="section level1">
<h1>Analyzing an epidemic with SEIR dynamics</h1>
<p>In this vignette, we will demonstrate how to implement the Particle Marginal Metropolis-Hastings (PMMH) algorithm (which has been implemented in the pomp package) for analyzing simulated prevalence counts. We fit SEIR models to binomially distributed prevalence counts.</p>
<p>We simulated an epidemic with SEIR dynamics in a population of 500 individuals. The epidemic was initiated by a single infected individual in an otherwise completely suscpetible population. The per–contact infectivity rate was <span class="math inline">\(\beta = 0.000075\)</span>, the average incubation period was <span class="math inline">\(1/\gamma=14\)</span> days, and the average infectious period duration was <span class="math inline">\(1/\mu = 28\)</span> days, which together correspond to a basic reproduction number of <span class="math inline">\(R_0 = \beta N / µ = 1.05\)</span>. Binomially sampled prevalence was observed at one week intervals over a period of two years with sampling probability <span class="math inline">\(\rho=1/3\)</span>.</p>
<p>The data simulation code is in “SIR_SEIR_SIRS” vignettes. And the data is shown below.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">1834</span>)
data&lt;-<span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">2</span>,<span class="dv">0</span>,<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">2</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">5</span>,<span class="dv">5</span>,<span class="dv">4</span>,<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">5</span>,<span class="dv">4</span>,<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">4</span>,<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">5</span>,<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>)</code></pre></div>
</div>
<div id="using-approximate-tau-leaping-algorithm" class="section level1">
<h1>Using Approximate Tau-leaping Algorithm:</h1>
<p>We use the SEIR model to model the dataset. The hosts are divided into four classes, according to their status. The susceptible class (S); the exposed class (E); the infected class (I); and the removed class (R). Individuals in R are assumed to be immune against reinfection. It is natural to formulate this model as a continuous-time Markov process. To start with, we need to specify the measurement model.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">rmeas&lt;-<span class="st">&quot;</span>
<span class="st">cases=rbinom(I,exp(rho)/(1+exp(rho)));//represent the data</span>
<span class="st">&quot;</span>
dmeas&lt;-<span class="st">&quot;</span>
<span class="st">lik=dbinom(cases,I,exp(rho)/(1+exp(rho)),give_log); //return the loglikelihood</span>
<span class="st">&quot;</span></code></pre></div>
<p>Here, we are using the <span class="math inline">\(\textbf{cases}\)</span> to refer to the data (number of reported cases) and <span class="math inline">\(\textbf{I}\)</span> to refer to the true incidence over the reporting interval. The binomial simulator rbinom and density function dbinom are provided by R. Notice that, in these snippets, we never declare the variables; pomp will ensure tht the state variable (<span class="math inline">\(\textbf{I}\)</span>), observables (<span class="math inline">\(\textbf{cases}\)</span>), parameters (<span class="math inline">\(\textbf{rho}\)</span>, <span class="math inline">\(\textbf{phi}\)</span>) and likelihood (<span class="math inline">\(\textbf{lik}\)</span>) are defined in the contexts within which these snippets are executed.</p>
<p>And for the transition of the SEIR model, we use a approximating tau-leaping algorithm, one version of which is implemented in the pomp package via the <span class="math inline">\(\bf{euler.sim}\)</span> plug-in. The algorithm holds the transition rates constant over a small interval of time and simulates the numbers of transitions that occur over the interval. The functions <span class="math inline">\(\textbf{reulermultinom}\)</span> draw random deviates from such distributions. Then we need to first specify a function that advances the states from <span class="math inline">\(t\)</span> to <span class="math inline">\(t+\triangle t\)</span>, and we give the trantition of the SIR model code below:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">seir.step&lt;-<span class="st">&quot;</span>
<span class="st">double rate[3];</span>
<span class="st">double dN[3];</span>
<span class="st">rate[0]=exp(beta)*I;   //Infection</span>
<span class="st">rate[1]=exp(gamma);    //Rate of S to E</span>
<span class="st">rate[2]=exp(mu);       //Rate of E to I</span>
<span class="st">reulermultinom(1,S,&amp;rate[0],dt,&amp;dN[0]);   //generate the number of newly from S to E</span>
<span class="st">reulermultinom(1,E,&amp;rate[1],dt,&amp;dN[1]);   //generate the number of newly from E to I</span>
<span class="st">reulermultinom(1,I,&amp;rate[2],dt,&amp;dN[2]);   //generate the number of newly from I to R</span>
<span class="st">if(!R_FINITE(S)) Rprintf(</span><span class="ch">\&quot;</span><span class="st">%lg %lg %lg %lg %lg %lg %lg %lg %lg</span><span class="ch">\\</span><span class="st">n</span><span class="ch">\&quot;</span><span class="st">,dN[0],rate[0],dN[1],rate[1],beta,mu,S,I,R);</span>
<span class="st">S+=-dN[0];       //update the number of Susceptible</span>
<span class="st">E+=dN[0]-dN[1];  //update the number of E</span>
<span class="st">I+=dN[1]-dN[2];  //update the number of I</span>
<span class="st">R+=dN[2];        //update the number of R</span>
<span class="st">&quot;</span></code></pre></div>
<p>The pomp will ensure that the undeclared state variables and parameters are defined in the context within which the snippet is executed. And the <span class="math inline">\(\textbf{rate}\)</span> and <span class="math inline">\(\textbf{dN}\)</span> arrays hold the rates and numbers of transition events, respectively. Then we could construct the pomp objects below:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">seir &lt;-<span class="st"> </span><span class="kw">pomp</span>(
  <span class="dt">data =</span> <span class="kw">data.frame</span>(<span class="dt">cases =</span> data, <span class="dt">time =</span> <span class="kw">seq</span>(<span class="dv">1</span>, <span class="dv">729</span>, <span class="dt">by =</span> <span class="dv">7</span>)), <span class="co">#&quot;cases&quot; is the dataset, &quot;time&quot; is the observation time</span>
  <span class="dt">times =</span> <span class="st">&quot;time&quot;</span>,
  <span class="dt">t0 =</span> <span class="dv">1</span>,  <span class="co">#initial time point</span>
  <span class="dt">dmeasure =</span> <span class="kw">Csnippet</span>(dmeas),
  <span class="dt">rmeasure =</span> <span class="kw">Csnippet</span>(rmeas),
  <span class="dt">rprocess =</span> <span class="kw">euler.sim</span>(<span class="dt">step.fun =</span> <span class="kw">Csnippet</span>(seir.step), <span class="dt">delta.t =</span> <span class="dv">1</span>/<span class="dv">12</span>), <span class="co"># tau-leaping over 2 hour intervals</span>
  <span class="dt">statenames =</span> <span class="kw">c</span>(<span class="st">&quot;S&quot;</span>, <span class="st">&quot;E&quot;</span>, <span class="st">&quot;I&quot;</span>, <span class="st">&quot;R&quot;</span>), <span class="co">#state space variable name</span>
  <span class="dt">paramnames =</span> <span class="kw">c</span>(<span class="st">&quot;beta&quot;</span>, <span class="st">&quot;gamma&quot;</span>, <span class="st">&quot;mu&quot;</span>, <span class="st">&quot;rho&quot;</span>, <span class="st">&quot;theta1&quot;</span>, <span class="st">&quot;theta2&quot;</span>, <span class="st">&quot;theta3&quot;</span>), <span class="co">#parameters name</span>
  <span class="dt">initializer =</span> function(params, t0, ...) {
            <span class="co">#Initial proportion of S, E, I, R</span>
            ps &lt;-<span class="st"> </span><span class="kw">exp</span>(params[<span class="st">&quot;theta1&quot;</span>]) /<span class="st"> </span>(<span class="dv">1</span> +<span class="st"> </span><span class="kw">exp</span>(params[<span class="st">&quot;theta1&quot;</span>]) +<span class="st"> </span><span class="kw">exp</span>(params[<span class="st">&quot;theta2&quot;</span>]) +<span class="st"> </span><span class="kw">exp</span>(params[<span class="st">&quot;theta3&quot;</span>]))
            pe &lt;-<span class="st"> </span><span class="kw">exp</span>(params[<span class="st">&quot;theta2&quot;</span>]) /<span class="st"> </span>(<span class="dv">1</span> +<span class="st"> </span><span class="kw">exp</span>(params[<span class="st">&quot;theta1&quot;</span>]) +<span class="st"> </span><span class="kw">exp</span>(params[<span class="st">&quot;theta2&quot;</span>]) +<span class="st"> </span><span class="kw">exp</span>(params[<span class="st">&quot;theta3&quot;</span>]))
            pi &lt;-<span class="st"> </span><span class="dv">1</span> /<span class="st"> </span>(<span class="dv">1</span> +<span class="st"> </span><span class="kw">exp</span>(params[<span class="st">&quot;theta1&quot;</span>]) +<span class="st"> </span><span class="kw">exp</span>(params[<span class="st">&quot;theta2&quot;</span>]) +<span class="st"> </span><span class="kw">exp</span>(params[<span class="st">&quot;theta3&quot;</span>]))
            pr &lt;-<span class="st"> </span><span class="kw">exp</span>(params[<span class="st">&quot;theta3&quot;</span>]) /<span class="st"> </span>(<span class="dv">1</span> +<span class="st"> </span><span class="kw">exp</span>(params[<span class="st">&quot;theta1&quot;</span>]) +<span class="st"> </span><span class="kw">exp</span>(params[<span class="st">&quot;theta2&quot;</span>]) +<span class="st"> </span><span class="kw">exp</span>(params[<span class="st">&quot;theta3&quot;</span>]))  
          <span class="kw">return</span>(<span class="kw">setNames</span>(<span class="kw">as.numeric</span>(<span class="kw">rmultinom</span>(<span class="dv">1</span>, <span class="dv">500</span>, <span class="dt">prob =</span> <span class="kw">c</span>(ps, pe, pi, pr))), <span class="kw">c</span>(<span class="st">&quot;S&quot;</span>, <span class="st">&quot;E&quot;</span>, <span class="st">&quot;I&quot;</span>, <span class="st">&quot;R&quot;</span>)))
  },
  <span class="dt">params =</span> <span class="kw">c</span>(
    <span class="dt">beta =</span> <span class="kw">log</span>(<span class="fl">0.00072</span>),
    <span class="dt">gamma =</span> <span class="kw">log</span>(<span class="fl">0.5</span>),
    <span class="dt">mu =</span> <span class="kw">log</span>(<span class="fl">0.2</span>),
    <span class="dt">rho =</span> <span class="kw">log</span>(<span class="dv">1</span> /<span class="st"> </span><span class="dv">4</span>),
    <span class="dt">theta1 =</span> <span class="kw">log</span>(<span class="dv">90</span>),
    <span class="dt">theta2 =</span> <span class="kw">log</span>(<span class="dv">2</span>),
    <span class="dt">theta3 =</span> <span class="kw">log</span>(<span class="dv">7</span>)
  )
)</code></pre></div>
<p>To carry out Bayesian inference we need to specify a prior distribution on unknown parame- ters. The pomp constructor function provides the rprior and dprior arguments, which can be filled with functions that simulate from and evaluate the prior density, respectively. Methods based on random walk Metropolis-Hastings require evaluation of the prior density (dprior), so we specify dprior for the SEIR model as follows.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">trans&lt;-function(a,b,c){
  a_t&lt;-<span class="kw">exp</span>(a)
  b_t&lt;-<span class="kw">exp</span>(b)
  c_t&lt;-<span class="kw">exp</span>(c)
  <span class="kw">return</span>(a_t*b_t*c_t/((<span class="dv">1</span>+a_t+b_t+c_t)^<span class="dv">4</span>))
}


seir.dprior &lt;-<span class="st"> </span>function(params, ..., log) {
          f &lt;-<span class="st"> </span>(<span class="kw">dgamma</span>(<span class="kw">exp</span>(params[<span class="dv">1</span>]), <span class="dv">1</span>, <span class="dv">10000</span>, <span class="dt">log =</span> <span class="ot">TRUE</span>) +<span class="st"> </span>params[<span class="dv">1</span>] +<span class="st">  </span><span class="co">#log prior for beta</span>
<span class="st">                          </span><span class="kw">dgamma</span>(<span class="kw">exp</span>(params[<span class="dv">2</span>]), <span class="dv">1</span>, <span class="dv">11</span>, <span class="dt">log =</span> <span class="ot">TRUE</span>) +<span class="st"> </span>params[<span class="dv">2</span>] +<span class="st">  </span><span class="co">#log prior for gamma</span>
<span class="st">                          </span><span class="kw">dgamma</span>(<span class="kw">exp</span>(params[<span class="dv">3</span>]), <span class="fl">3.2</span>, <span class="dv">100</span>, <span class="dt">log =</span> <span class="ot">TRUE</span>) +<span class="st"> </span>params[<span class="dv">3</span>] +<span class="st">   </span><span class="co">#log prior for mu</span>
<span class="st">                          </span><span class="kw">dbeta</span>(<span class="kw">exp</span>(params[<span class="dv">4</span>]) /<span class="st"> </span>(<span class="dv">1</span> +<span class="st"> </span><span class="kw">exp</span>(params[<span class="dv">4</span>])), <span class="fl">3.5</span>, <span class="fl">6.5</span>, <span class="dt">log =</span> <span class="ot">TRUE</span>) +
<span class="st">                          </span>params[<span class="dv">4</span>] -<span class="st"> </span><span class="kw">log</span>((<span class="dv">1</span> +<span class="st"> </span><span class="kw">exp</span>(params[<span class="dv">4</span>])) ^<span class="st"> </span><span class="dv">2</span>) +<span class="st">      </span><span class="co">#log prior for rho</span>
<span class="st">                          </span><span class="kw">log</span>(<span class="kw">ddirichlet</span>(<span class="kw">c</span>(<span class="kw">exp</span>(params[<span class="dv">5</span>]) /<span class="st"> </span>(<span class="dv">1</span> +<span class="st"> </span><span class="kw">exp</span>(params[<span class="dv">5</span>]) +<span class="st"> </span><span class="kw">exp</span>(params[<span class="dv">6</span>]) +<span class="st"> </span><span class="kw">exp</span>(params[<span class="dv">7</span>])),
                                           <span class="kw">exp</span>(params[<span class="dv">6</span>]) /<span class="st"> </span>(<span class="dv">1</span> +<span class="st"> </span><span class="kw">exp</span>(params[<span class="dv">5</span>]) +<span class="st"> </span><span class="kw">exp</span>(params[<span class="dv">6</span>]) +<span class="st"> </span><span class="kw">exp</span>(params[<span class="dv">7</span>])),
                                           <span class="dv">1</span> /<span class="st"> </span>(<span class="dv">1</span> +<span class="st"> </span><span class="kw">exp</span>(params[<span class="dv">5</span>]) +<span class="st"> </span><span class="kw">exp</span>(params[<span class="dv">6</span>]) +<span class="st"> </span><span class="kw">exp</span>(params[<span class="dv">7</span>])),
                                           <span class="kw">exp</span>(params[<span class="dv">7</span>]) /<span class="st"> </span>(<span class="dv">1</span> +<span class="st"> </span><span class="kw">exp</span>(params[<span class="dv">5</span>]) +<span class="st"> </span><span class="kw">exp</span>(params[<span class="dv">6</span>]) +<span class="st"> </span><span class="kw">exp</span>(params[<span class="dv">7</span>]))),
                                         <span class="kw">c</span>(<span class="dv">100</span>, <span class="fl">0.01</span>, <span class="fl">0.4</span>, <span class="fl">0.01</span>)) *<span class="st"> </span><span class="kw">trans</span>(params[<span class="dv">5</span>], params[<span class="dv">6</span>], params[<span class="dv">7</span>]))  <span class="co">#log prior for initial SEIR value</span>
          )
          if (log) {
                    f
          } else {
                    <span class="kw">exp</span>(f)
          }
}</code></pre></div>
<p>And starting value of the PMMH is specified below:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">param.initial&lt;-<span class="st"> </span><span class="kw">c</span>(
  <span class="dt">beta =</span> <span class="kw">log</span>(<span class="kw">abs</span>(<span class="kw">rnorm</span>(<span class="dv">1</span>, <span class="fl">0.00005</span>, <span class="fl">1e-6</span>))),
  <span class="dt">gamma =</span> <span class="kw">log</span>(<span class="kw">abs</span>(<span class="kw">rnorm</span>(<span class="dv">1</span>, <span class="fl">0.15</span>, <span class="fl">0.01</span>))),
  <span class="dt">mu =</span> <span class="kw">log</span>(<span class="kw">abs</span>(<span class="kw">rnorm</span>(<span class="dv">1</span>, <span class="fl">0.04</span>, <span class="fl">0.001</span>))),
  <span class="dt">rho =</span> -<span class="dv">1</span>,
  <span class="dt">theta1 =</span> <span class="dv">5</span>,
  <span class="dt">theta2 =</span> <span class="dv">1</span>,
  <span class="dt">theta3 =</span> <span class="dv">1</span>
)</code></pre></div>
<p>And the following runs 1 PMMH chain for 5000 tunning steps (using 200 particles) to get a suitable multivariate normal random walk proposal diagonal variance-covariance matrix value.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">pmcmc1 &lt;-<span class="st"> </span><span class="kw">pmcmc</span>(
          <span class="kw">pomp</span>(seir, <span class="dt">dprior =</span> seir.dprior),
          <span class="co">#given the prior function</span>
          <span class="dt">start =</span> param.initial,
          <span class="co">#given the initial value of the parameters</span>
          <span class="dt">Nmcmc =</span> <span class="dv">10</span>,
          <span class="co">#number of mcmc steps</span>
          <span class="dt">Np =</span> <span class="dv">200</span>,
          <span class="dt">max.fail =</span> <span class="ot">Inf</span>,
          <span class="dt">proposal =</span> <span class="kw">mvn.rw.adaptive</span>(
                    <span class="fl">0.5</span> *<span class="st"> </span><span class="kw">c</span>(
                              <span class="dt">beta =</span> <span class="fl">0.1</span>,
                              <span class="co">#sampling variance for beta</span>
                              <span class="dt">gamma =</span> <span class="fl">0.1</span>,
                              <span class="co">#sampling variance for gamma</span>
                              <span class="dt">mu =</span> <span class="fl">0.1</span>,
                              <span class="co">#sampling variance for mu</span>
                              <span class="dt">rho =</span> <span class="fl">0.1</span>,
                              <span class="co">#sampling variance for rho</span>
                              <span class="dt">theta1 =</span> <span class="fl">0.1</span>,
                              <span class="co">#sampling variance for theta1</span>
                              <span class="dt">theta2 =</span> <span class="fl">0.1</span>,
                              <span class="co">#sampling variance for theta2</span>
                              <span class="dt">theta3 =</span> <span class="fl">0.1</span> <span class="co">#sampling variance for theta3</span>
                    ), 
                    <span class="dt">scale.start =</span> <span class="dv">100</span>, 
                    <span class="dt">shape.start =</span> <span class="dv">100</span>
          )
)</code></pre></div>
<p>And the following runs 1 PMMH chain for 100000 steps (using 200 particles) with suitable multivariate normal random walk proposal diagonal variance-covariance matrix value we get above to get the posterior distribution of the interested parameters.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">start_time &lt;-<span class="st"> </span><span class="kw">Sys.time</span>();  <span class="co">#calculation of time</span>
pmcmc1 &lt;-<span class="st"> </span><span class="kw">pmcmc</span>(
          pmcmc1,
          <span class="co">#given the prior function</span>
          <span class="dt">start =</span> param.initial,
          <span class="co">#given the initial value of the parameters</span>
          <span class="dt">Nmcmc =</span> <span class="dv">10</span>,
          <span class="dt">max.fail =</span> <span class="ot">Inf</span>,
          <span class="dt">proposal =</span> <span class="kw">mvn.rw</span>(<span class="kw">covmat</span>(pmcmc1))
)

end_time &lt;-<span class="st"> </span><span class="kw">Sys.time</span>(); <span class="co">#calculation of time</span>
run_time &lt;-<span class="st"> </span><span class="kw">difftime</span>(end_time, start_time, <span class="dt">units =</span> <span class="st">&quot;hours&quot;</span>) <span class="co">#calculation of time</span>

pomp_results &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">time =</span> run_time, <span class="dt">results =</span> pmcmc1) </code></pre></div>
</div>
<div id="using-exact-gillespie-algorithm" class="section level1">
<h1>Using Exact Gillespie Algorithm:</h1>
<p>We use the SEIR model to model the dataset. The hosts are divided into four classes, according to their status. The susceptible class (S); the exposed class (E); the infected class (I); and the removed class (R). Individuals in R are assumed to be immune against reinfection. It is natural to formulate this model as a continuous-time Markov process. To start with, we need to specify the measurement model.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">rmeas&lt;-<span class="st">&quot;</span>
<span class="st">cases=rbinom(I,exp(rho)/(1+exp(rho)));//represent the data</span>
<span class="st">&quot;</span>
dmeas&lt;-<span class="st">&quot;</span>
<span class="st">lik=dbinom(cases,I,exp(rho)/(1+exp(rho)),give_log); //return the loglikelihood</span>
<span class="st">&quot;</span></code></pre></div>
<p>Here, we are using the <span class="math inline">\(\textbf{cases}\)</span> to refer to the data (number of reported cases) and <span class="math inline">\(\textbf{I}\)</span> to refer to the true incidence over the reporting interval. The binomial simulator rbinom and density function dbinom are provided by R. Notice that, in these snippets, we never declare the variables; pomp will ensure tht the state variable (<span class="math inline">\(\textbf{I}\)</span>), observables (<span class="math inline">\(\textbf{cases}\)</span>), parameters (<span class="math inline">\(\textbf{rho}\)</span>, <span class="math inline">\(\textbf{phi}\)</span>) and likelihood (<span class="math inline">\(\textbf{lik}\)</span>) are defined in the contexts within which these snippets are executed.</p>
<p>And for the transition of the SEIR model, we use an exact gillespie algorithm, one version of which is implemented in the pomp package via the <span class="math inline">\(\bf{gillespie.sim}\)</span> plug-in. We give the trantition of the SIR model code below:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># define the rate function, stoichiometry matrix, and rate-event dependency matrix</span>
SEIR_stoich &lt;-<span class="st"> </span><span class="kw">cbind</span>(<span class="dt">exposure  =</span> <span class="kw">c</span>(-<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>), <span class="co"># exposures yield S-1, E+1</span>
                     <span class="dt">infection =</span> <span class="kw">c</span>(<span class="dv">0</span>, -<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>), <span class="co"># infections yield E-1, I+1</span>
                     <span class="dt">recovery  =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">0</span>, -<span class="dv">1</span>, <span class="dv">1</span>)) <span class="co"># recoveries yield I-1, R+1</span>

SEIR_depmat &lt;-<span class="st"> </span><span class="kw">cbind</span>(<span class="dt">exposure  =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>), <span class="co"># exposure rate updated by changes to S and I</span>
                     <span class="dt">infection =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>), <span class="co"># infection rate updated by changes to E</span>
                     <span class="dt">recovery  =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>)) <span class="co"># recovery rate updated by changes to I</span>
<span class="co"># SIR rate function</span>
<span class="co"># j the number of the elementary event (1 = infection, 2 = recovery)</span>
<span class="co"># x named numeric vector with the value of the state of the process at time t</span>
<span class="co"># t time</span>
<span class="co"># params named numeric vector containing the parameters</span>
<span class="co"># returns single numerical value with the rate of the elementary event</span>
SEIR_rates &lt;-<span class="st"> </span>function(j, x, t, params, ...) {
          switch(j,
                 <span class="kw">exp</span>(params[<span class="st">&quot;beta&quot;</span>]) *<span class="st"> </span>x[<span class="st">&quot;S&quot;</span>] *<span class="st"> </span>x[<span class="st">&quot;I&quot;</span>], <span class="co"># exposure</span>
                 <span class="kw">exp</span>(params[<span class="st">&quot;gamma&quot;</span>]) *<span class="st"> </span>x[<span class="st">&quot;E&quot;</span>], <span class="co"># infection</span>
                 <span class="kw">exp</span>(params[<span class="st">&quot;mu&quot;</span>]) *<span class="st"> </span>x[<span class="st">&quot;I&quot;</span>] <span class="co"># recovery</span>
          )
}

<span class="co"># instatiate the gillespie stepper function</span>
SEIR_sim &lt;-<span class="st"> </span><span class="kw">gillespie.sim</span>(<span class="dt">rate.fun =</span> SEIR_rates,
                          <span class="dt">v =</span> SEIR_stoich,
                          <span class="dt">d =</span> SEIR_depmat)</code></pre></div>
<p>The pomp will ensure that the undeclared state variables and parameters are defined in the context within which the snippet is executed. And the <span class="math inline">\(\textbf{rate}\)</span> and <span class="math inline">\(\textbf{dN}\)</span> arrays hold the rates and numbers of transition events, respectively. Then we could construct the pomp objects below:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">seir &lt;-<span class="st"> </span><span class="kw">pomp</span>(
          <span class="dt">data =</span> <span class="kw">data.frame</span>(<span class="dt">time =</span> <span class="kw">seq</span>(<span class="dv">1</span>, <span class="dv">729</span>, <span class="dt">by =</span> <span class="dv">7</span>), <span class="dt">cases =</span> data),  <span class="co">#&quot;cases&quot; is the dataset, &quot;time&quot; is the observation time</span>
          <span class="dt">times =</span> <span class="st">&quot;time&quot;</span>,
          <span class="dt">t0 =</span> <span class="dv">1</span>,                      <span class="co"># initial time point</span>
          <span class="dt">dmeasure =</span> <span class="kw">Csnippet</span>(dmeas),  <span class="co"># evaluates the density of the measurement process</span>
          <span class="dt">rmeasure =</span> <span class="kw">Csnippet</span>(rmeas),  <span class="co"># simulates from the measurement process</span>
          <span class="dt">rprocess =</span> SEIR_sim,          <span class="co"># simulates from the latent process</span>
          <span class="dt">statenames =</span> <span class="kw">c</span>(<span class="st">&quot;S&quot;</span>, <span class="st">&quot;E&quot;</span>, <span class="st">&quot;I&quot;</span>, <span class="st">&quot;R&quot;</span>),  <span class="co">#state space variable name</span>
          <span class="dt">paramnames =</span> <span class="kw">c</span>(<span class="st">&quot;beta&quot;</span>, <span class="st">&quot;gamma&quot;</span>, <span class="st">&quot;mu&quot;</span>, <span class="st">&quot;rho&quot;</span>, <span class="st">&quot;theta1&quot;</span>, <span class="st">&quot;theta2&quot;</span>, <span class="st">&quot;theta3&quot;</span>), <span class="co">#parameters name</span>
          <span class="dt">initializer =</span> function(params, t0, ...) {
                    <span class="co">#Initial proportion of S, E, I, R</span>
                    ps &lt;-<span class="st"> </span><span class="kw">exp</span>(params[<span class="st">&quot;theta1&quot;</span>]) /<span class="st"> </span>(<span class="dv">1</span> +<span class="st"> </span><span class="kw">exp</span>(params[<span class="st">&quot;theta1&quot;</span>]) +<span class="st"> </span><span class="kw">exp</span>(params[<span class="st">&quot;theta2&quot;</span>]) +<span class="st"> </span><span class="kw">exp</span>(params[<span class="st">&quot;theta3&quot;</span>]))
                    pe &lt;-<span class="st"> </span><span class="kw">exp</span>(params[<span class="st">&quot;theta2&quot;</span>]) /<span class="st"> </span>(<span class="dv">1</span> +<span class="st"> </span><span class="kw">exp</span>(params[<span class="st">&quot;theta1&quot;</span>]) +<span class="st"> </span><span class="kw">exp</span>(params[<span class="st">&quot;theta2&quot;</span>]) +<span class="st"> </span><span class="kw">exp</span>(params[<span class="st">&quot;theta3&quot;</span>]))
                    pi &lt;-<span class="st"> </span><span class="dv">1</span> /<span class="st"> </span>(<span class="dv">1</span> +<span class="st"> </span><span class="kw">exp</span>(params[<span class="st">&quot;theta1&quot;</span>]) +<span class="st"> </span><span class="kw">exp</span>(params[<span class="st">&quot;theta2&quot;</span>]) +<span class="st"> </span><span class="kw">exp</span>(params[<span class="st">&quot;theta3&quot;</span>]))
                    pr &lt;-<span class="st"> </span><span class="kw">exp</span>(params[<span class="st">&quot;theta3&quot;</span>]) /<span class="st"> </span>(<span class="dv">1</span> +<span class="st"> </span><span class="kw">exp</span>(params[<span class="st">&quot;theta1&quot;</span>]) +<span class="st"> </span><span class="kw">exp</span>(params[<span class="st">&quot;theta2&quot;</span>]) +<span class="st"> </span><span class="kw">exp</span>(params[<span class="st">&quot;theta3&quot;</span>]))  
                    <span class="kw">return</span>(<span class="kw">setNames</span>(<span class="kw">as.numeric</span>(<span class="kw">rmultinom</span>(<span class="dv">1</span>, <span class="dv">500</span>, <span class="dt">prob =</span> <span class="kw">c</span>(ps, pe, pi, pr))), <span class="kw">c</span>(<span class="st">&quot;S&quot;</span>, <span class="st">&quot;E&quot;</span>, <span class="st">&quot;I&quot;</span>, <span class="st">&quot;R&quot;</span>)))
          },
          <span class="dt">params =</span> <span class="kw">c</span>(
                    <span class="dt">beta =</span> <span class="kw">log</span>(<span class="fl">0.00072</span>),
                    <span class="dt">gamma =</span> <span class="kw">log</span>(<span class="fl">0.5</span>),
                    <span class="dt">mu =</span> <span class="kw">log</span>(<span class="fl">0.2</span>),
                    <span class="dt">rho =</span> <span class="kw">log</span>(<span class="dv">1</span> /<span class="st"> </span><span class="dv">4</span>),
                    <span class="dt">theta1 =</span> <span class="kw">log</span>(<span class="dv">90</span>),
                    <span class="dt">theta2 =</span> <span class="kw">log</span>(<span class="dv">2</span>),
                    <span class="dt">theta3 =</span> <span class="kw">log</span>(<span class="dv">7</span>)
          )
)</code></pre></div>
<p>To carry out Bayesian inference we need to specify a prior distribution on unknown parame- ters. The pomp constructor function provides the rprior and dprior arguments, which can be filled with functions that simulate from and evaluate the prior density, respectively. Methods based on random walk Metropolis-Hastings require evaluation of the prior density (dprior), so we specify dprior for the SEIR model as follows.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">trans&lt;-function(a,b,c){
          a_t&lt;-<span class="kw">exp</span>(a)
          b_t&lt;-<span class="kw">exp</span>(b)
          c_t&lt;-<span class="kw">exp</span>(c)
          <span class="kw">return</span>(a_t*b_t*c_t/((<span class="dv">1</span>+a_t+b_t+c_t)^<span class="dv">4</span>))
} <span class="co">#Jacobian for (theta1, theta2, theta3)</span>

seir.dprior &lt;-<span class="st"> </span>function(params, ..., log) {
          f &lt;-<span class="st"> </span>(<span class="kw">dgamma</span>(<span class="kw">exp</span>(params[<span class="dv">1</span>]), <span class="dv">1</span>, <span class="dv">10000</span>, <span class="dt">log =</span> <span class="ot">TRUE</span>) +<span class="st"> </span>params[<span class="dv">1</span>] +<span class="st">  </span><span class="co">#log prior for beta</span>
<span class="st">                          </span><span class="kw">dgamma</span>(<span class="kw">exp</span>(params[<span class="dv">2</span>]), <span class="dv">1</span>, <span class="dv">11</span>, <span class="dt">log =</span> <span class="ot">TRUE</span>) +<span class="st"> </span>params[<span class="dv">2</span>] +<span class="st">  </span><span class="co">#log prior for gamma</span>
<span class="st">                          </span><span class="kw">dgamma</span>(<span class="kw">exp</span>(params[<span class="dv">3</span>]), <span class="fl">3.2</span>, <span class="dv">100</span>, <span class="dt">log =</span> <span class="ot">TRUE</span>) +<span class="st"> </span>params[<span class="dv">3</span>] +<span class="st">   </span><span class="co">#log prior for mu</span>
<span class="st">                          </span><span class="kw">dbeta</span>(<span class="kw">exp</span>(params[<span class="dv">4</span>]) /<span class="st"> </span>(<span class="dv">1</span> +<span class="st"> </span><span class="kw">exp</span>(params[<span class="dv">4</span>])), <span class="fl">3.5</span>, <span class="fl">6.5</span>, <span class="dt">log =</span> <span class="ot">TRUE</span>) +
<span class="st">                          </span>params[<span class="dv">4</span>] -<span class="st"> </span><span class="kw">log</span>((<span class="dv">1</span> +<span class="st"> </span><span class="kw">exp</span>(params[<span class="dv">4</span>])) ^<span class="st"> </span><span class="dv">2</span>) +<span class="st">      </span><span class="co">#log prior for rho</span>
<span class="st">                          </span><span class="kw">log</span>(<span class="kw">ddirichlet</span>(<span class="kw">c</span>(<span class="kw">exp</span>(params[<span class="dv">5</span>]) /<span class="st"> </span>(<span class="dv">1</span> +<span class="st"> </span><span class="kw">exp</span>(params[<span class="dv">5</span>]) +<span class="st"> </span><span class="kw">exp</span>(params[<span class="dv">6</span>]) +<span class="st"> </span><span class="kw">exp</span>(params[<span class="dv">7</span>])),
                                           <span class="kw">exp</span>(params[<span class="dv">6</span>]) /<span class="st"> </span>(<span class="dv">1</span> +<span class="st"> </span><span class="kw">exp</span>(params[<span class="dv">5</span>]) +<span class="st"> </span><span class="kw">exp</span>(params[<span class="dv">6</span>]) +<span class="st"> </span><span class="kw">exp</span>(params[<span class="dv">7</span>])),
                                           <span class="dv">1</span> /<span class="st"> </span>(<span class="dv">1</span> +<span class="st"> </span><span class="kw">exp</span>(params[<span class="dv">5</span>]) +<span class="st"> </span><span class="kw">exp</span>(params[<span class="dv">6</span>]) +<span class="st"> </span><span class="kw">exp</span>(params[<span class="dv">7</span>])),
                                           <span class="kw">exp</span>(params[<span class="dv">7</span>]) /<span class="st"> </span>(<span class="dv">1</span> +<span class="st"> </span><span class="kw">exp</span>(params[<span class="dv">5</span>]) +<span class="st"> </span><span class="kw">exp</span>(params[<span class="dv">6</span>]) +<span class="st"> </span><span class="kw">exp</span>(params[<span class="dv">7</span>]))),
                                         <span class="kw">c</span>(<span class="dv">100</span>, <span class="fl">0.01</span>, <span class="fl">0.4</span>, <span class="fl">0.01</span>)) *<span class="st"> </span><span class="kw">trans</span>(params[<span class="dv">5</span>], params[<span class="dv">6</span>], params[<span class="dv">7</span>]))  <span class="co">#log prior for initial SEIR value</span>
          )
          if (log) {
                    f
          } else {
                    <span class="kw">exp</span>(f)
          }
}</code></pre></div>
<p>And starting value of the PMMH is specified below:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">param.initial&lt;-<span class="st"> </span><span class="kw">c</span>(
          <span class="dt">beta =</span> <span class="kw">log</span>(<span class="kw">abs</span>(<span class="kw">rnorm</span>(<span class="dv">1</span>, <span class="fl">0.00005</span>, <span class="fl">1e-6</span>))),
          <span class="dt">gamma =</span> <span class="kw">log</span>(<span class="kw">abs</span>(<span class="kw">rnorm</span>(<span class="dv">1</span>, <span class="fl">0.15</span>, <span class="fl">0.01</span>))),
          <span class="dt">mu =</span> <span class="kw">log</span>(<span class="kw">abs</span>(<span class="kw">rnorm</span>(<span class="dv">1</span>, <span class="fl">0.04</span>, <span class="fl">0.001</span>))),
          <span class="dt">rho =</span> -<span class="dv">1</span>,
          <span class="dt">theta1 =</span> <span class="dv">5</span>,
          <span class="dt">theta2 =</span> <span class="dv">1</span>,
          <span class="dt">theta3 =</span> <span class="dv">1</span>
)</code></pre></div>
<p>And the following runs 1 PMMH chain for 5000 tunning steps (using 200 particles) to get a suitable multivariate normal random walk proposal diagonal variance-covariance matrix value.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">pmcmc1 &lt;-<span class="st"> </span><span class="kw">pmcmc</span>(
          <span class="kw">pomp</span>(seir, <span class="dt">dprior =</span> seir.dprior),
          <span class="co">#given the prior function</span>
          <span class="dt">start =</span> param.initial,
          <span class="co">#given the initial value of the parameters</span>
          <span class="dt">Nmcmc =</span> <span class="dv">10</span>,
          <span class="co">#number of mcmc steps</span>
          <span class="dt">Np =</span> <span class="dv">200</span>,
          <span class="dt">max.fail =</span> <span class="ot">Inf</span>,
          <span class="dt">proposal =</span> <span class="kw">mvn.rw.adaptive</span>(<span class="fl">0.5</span> *<span class="st"> </span><span class="kw">c</span>(
                    <span class="dt">beta =</span> <span class="fl">0.1</span>,
                    <span class="co">#sampling variance for beta</span>
                    <span class="dt">gamma =</span> <span class="fl">0.1</span>,
                    <span class="co">#sampling variance for gamma</span>
                    <span class="dt">mu =</span> <span class="fl">0.1</span>,
                    <span class="co">#sampling variance for mu</span>
                    <span class="dt">rho =</span> <span class="fl">0.1</span>,
                    <span class="co">#sampling variance for rho</span>
                    <span class="dt">theta1 =</span> <span class="fl">0.1</span>,
                    <span class="co">#sampling variance for theta1</span>
                    <span class="dt">theta2 =</span> <span class="fl">0.1</span>,
                    <span class="co">#sampling variance for theta2</span>
                    <span class="dt">theta3 =</span> <span class="fl">0.1</span> <span class="co">#sampling variance for theta3</span>
          ), 
          <span class="dt">scale.start =</span> <span class="dv">100</span>, 
          <span class="dt">shape.start =</span> <span class="dv">100</span>)
)</code></pre></div>
<p>And the following runs 1 PMMH chain for 100000 steps (using 200 particles) with suitable multivariate normal random walk proposal diagonal variance-covariance matrix value we get above to get the posterior distribution of the interested parameters.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">start_time &lt;-<span class="st"> </span><span class="kw">Sys.time</span>();  <span class="co">#calculation of time</span>
pmcmc1 &lt;-<span class="st"> </span><span class="kw">pmcmc</span>(
          pmcmc1,
          <span class="co">#given the prior function</span>
          <span class="dt">start =</span> param.initial,
          <span class="co">#given the initial value of the parameters</span>
          <span class="dt">Nmcmc =</span> <span class="dv">10</span>,
          <span class="dt">max.fail =</span> <span class="ot">Inf</span>,
          <span class="dt">proposal =</span> <span class="kw">mvn.rw</span>(<span class="kw">covmat</span>(pmcmc1))
)

end_time &lt;-<span class="st"> </span><span class="kw">Sys.time</span>(); <span class="co">#calculation of time</span>
run_time &lt;-<span class="st"> </span><span class="kw">difftime</span>(end_time, start_time, <span class="dt">units =</span> <span class="st">&quot;hours&quot;</span>) <span class="co">#calculation of time</span>

pomp_results &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">time =</span> run_time, <span class="dt">results =</span> pmcmc1) </code></pre></div>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
